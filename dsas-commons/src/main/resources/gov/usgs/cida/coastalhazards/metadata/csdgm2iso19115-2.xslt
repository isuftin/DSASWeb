<?xml version="1.0" encoding="UTF-8"?>
<!--
======================================================================
	FGDC CSDGM to ISO 19115-2 Transform using XPath 2.0 January 2013

	This is the XML Style sheet that transforms metadata conforming to the Content Standards
	for Digital Geospatial Metadata of the Federal Geographic Data Committee June 1998 
	FGDC-STD-001-1999 version to the ISO 19115-2:2009(E).  This stylesheet can be applied
	to FGDC CSDGM XML to generate ISO 19115-2 XML.

	This file was generated by Altova MapForce 2009sp1

	Authors:
	This is the result of a collaboration of the Metadata Transform Working Group. 
	For further information, please contact NOAA's National Coastal Data 
	Development Center (NCDDC).
				National Coastal Data Development Center
				Toll Free: 866.732.2382
				E-mail: ncddcmetadata@noaa.gov

	Distribution Liability:
		NOAA makes no warranty regarding these data, expressed or implied, 
		nor does the fact of distribution constitute such a warranty. NOAA, NESDIS, 
		NODC and NCDDC cannot assume liability for any damages caused by any 
		errors or omissions in these data, nor as a result of the failure of these data 
		to function on a particular system. These files were developed for opensource uses.
	
	Use Constraints:
		The user is responsible for the results of any application of these transforms for other than its
		intended purpose. These transforms cannot guarantee valid output. Additional editing
		may need to be done in order to have valid records. The intent of these transforms is
		to get as much of the FGDC valid content mapped to ISO content as possible but cannot 
		guarantee against loss of information. Please feel free to edit transforms as needed for 
		your organizations needs. 

	Revisions:
		20091028 (JLM) Namespaces were corrected to avoid duplicates.
							 xmlns:n="http://www.isotc211.org/2005/gfc" was changed
							 to xmlns:gfc="http://www.isotc211.org/2005/gfc" and
							 xmlns:n="http://www.opengis.net/gml/3.2" was changed to
							 xmlns:gml="http://www.opengis.net/gml/3.2". All used "n:" 
							 namespaces were changed to "gmi:". 
		20091120 (JLM) CodeLists were edited to remove extra quotes and other.
							 undesired characters. CodeLists were checked to ensure 
							 inclusion of domian codes. Edits were also made to remove 
							 un-used elements. FGDC CSDGM elements horizpa/horizpar and 
							 vertacc/vertaccr were changed from being mapped to gml:id to 
							 gml:CoventionalUnit. Single Date Time Period of contect was
							 added to mapping. Multiple Dates will replace if single date 
							 is empty. Duplicates of axisDimensionsProperties is not
							 allowed to repeat. To solve this, MD_GridSpatialRepresentation
							 was repeated. Cell Geometry Code information was also added.
		20100323 (JLM) Repeatability issues (repeating at characterString level instead
							 of attribute level) were fixed with grouping. Stratum Keyword 
							 thesauri and keywords were corrected. These elements were 
							 switched in the previous mappings. 'Unknown' was added as default
							 value to Spatial Rep. transformation parameter ability. 'Unknown' was 
							 added a default for mandatory fields that did not have content exist in
							 the FGDC source record. Extra spaces were removed from dates. 
		20100407 (JLM) Cleaned up the dates and also removed un-used elements.
		20100503 (JLM) Changed the MD_ root to MI_ to be more interoperable. Also added 
							 fileIdentifier.
		20100721 (JLM) Added Extent ids.
		20100811 (JLM) Removed mapping of onlink linkage to datasetURI, instead mapped to 
							 Dist Info linkage URL. 
		20100223 (JLM) Corrected for error not mapping otherConstraints. Corrected error to
							 repeat at gmd:distributionFormat instead of name and version. Changed 
							 language from 'eng' to 'eng; USA'. Corrected ISO name and version. 
							 Made allowances for srcscal = "unknown". 
		20110210 (JLM) Added logic to remove number values from Topic Category. 
		20110224 (JLM) Fixed keyword issues. Added spatial representation type code content between 
							 tags. 'Entity and Attribute Information' was added as the default title value for 
							 feature catalogue citation.'unknown' was added as default date for feature catalogue 
							 citation. Updated metadata standard name and version to use best practices. Added 
							 role to aggregation information responsible party. Corrected codeList in aggregation
							 information. Deleted empty element tags. If reference system RS_Identifier code
							 was missing, set the default value to 'unknown'. Moved EX_BoundingPolygon id 
							 to Polygon id. Corrected report issues in data quality. Corrected date/time issues.
		20110419 (JLM) Corrected online resource and distribution info issues. Corrected cross reference
							 date/time issues. Added which version of transform was used in metadata maintenance.
		20110502 (JLM) Corrected issues found when there were multiple source dates within lineage. 
		20110617 (JLM) Corrected the hardcoding of "Unknown" to "unknown" for nilReason. Corrected repeatability 
							 of MD_Constraints if both metadata legal and security constraints exist. Added mapping from 
							 spref>horizsys>geograph to spatialRepresentationInfo>MD_GridSpatialRep. Corrected error 
							 produced if cloud cover percentage is a number or if it contains "Unknown". Corrected location 
							 of temporal extent IDs.  Corrected Dist Info and online linkages. Corrected publisher information 
							 not displaying in data identification. Corrected planned available date/times not showing (unknown 
							 times will not display,  that is an optional field).  Removed FGDC extension  information from mapping. 
							 Added maintenance note about spatial ref. Corrected bounding coordinates from type double 
							 (in FGDC) to type decimal (in ISO) to prevent the addition of extra decimal spaces. Added mapping of 
							 cross reference publisher info. Added mapping of cross reference online link. 
		20111115 (JLM) Added other domain values to the value map between geographic coordinate units and resolution scale uom. Previously only "Decimal
							 degrees" would map. 
		20120629 (JLM) Added some spatial reference logic to add components to reference system info.
		20130124 (JLM) Updated mapping of attraccr (was not mapping previously if quattracc was missing) to create a new data quality report at DQ_NonQuantitativeAttributeAccuracy>measureDescription and using nilReason=inapplicable result.
-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gmi="http://www.isotc211.org/2005/gmi" xmlns:gmx="http://www.isotc211.org/2005/gmx" xmlns:gsr="http://www.isotc211.org/2005/gsr" xmlns:gss="http://www.isotc211.org/2005/gss" xmlns:gts="http://www.isotc211.org/2005/gts" xmlns:gml="http://www.opengis.net/gml/3.2" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vmf="http://www.altova.com/MapForce/UDF/vmf" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:grp="http://www.altova.com/Mapforce/grouping" exclude-result-prefixes="fn grp vmf xs xsi xsl" xmlns="http://www.isotc211.org/2005/gmi">
	<xsl:template name="vmf:vmf1_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='PIXEL'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
			<xsl:when test="$input='VOXEL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf2_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='PIXEL'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='VOXEL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf3_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='ENTITY POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='LABEL POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='AREA POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, NETWORK'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='STRING'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='LINK'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE CHAIN'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='ELLIPTICAL ARC'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='UNIFORM B-SPLINE'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='PIECEWISE BEZIER'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf4_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='ENTITY POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='LABEL POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='AREA POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, NETWORK'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='STRING'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='LINK'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE CHAIN'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='ELLIPTICAL ARC'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='UNIFORM B-SPLINE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='PIECEWISE BEZIER'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf5_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='Decimal degrees'">
				<xsl:value-of select="'decimalDegrees'"/>
			</xsl:when>
			<xsl:when test="$input='Decimal minutes'">
				<xsl:value-of select="'decimalMinutes'"/>
			</xsl:when>
			<xsl:when test="$input='Decimal seconds'">
				<xsl:value-of select="'decimalSeconds'"/>
			</xsl:when>
			<xsl:when test="$input='Degrees and decimal minutes'">
				<xsl:value-of select="'degreesAndDecimalMinutes'"/>
			</xsl:when>
			<xsl:when test="$input='Degrees, minutes, and decimal seconds'">
				<xsl:value-of select="'degreesMinutesAndDecimalSeconds'"/>
			</xsl:when>
			<xsl:when test="$input='Radians'">
				<xsl:value-of select="'radians'"/>
			</xsl:when>
			<xsl:when test="$input='Grads'">
				<xsl:value-of select="'grads'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf6_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf7_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DIAGRAM'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DOCUMENT'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'documentHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MAP'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PRINTED MAP'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'modelDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODELl'">
				<xsl:value-of select="'modelHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'profileDigital'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'videoDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIEW'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DATABASE'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf8_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DIAGRAM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DOCUMENT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='MAP'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='PRINTED MAP'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODELl'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input='VIEW'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='DATABASE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf9_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'historicalArchive'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'obsolete'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'planned'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'required'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
			<xsl:when test="$input='IN WORK'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf10_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='IN WORK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf11_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'continual'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'daily'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'weekly'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'fortnightly'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'monthly'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'quarterly'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'biannually'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='YEARLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'asNeeded'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'irregular'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='NONE PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
			<xsl:when test="$input='NONE'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf12_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='YEARLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='NONE PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input='NONE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'012'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf13_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'confidential'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'topSecret'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'unclassified'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'restricted'"/>
			</xsl:when>
			<xsl:when test="$input='SECERT'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf14_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='SECERT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf15_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER'">
				<xsl:value-of select="'grid'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf16_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='vector'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='grid'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf17_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='farming'">
				<xsl:value-of select="'farming'"/>
			</xsl:when>
			<xsl:when test="$input='biota'">
				<xsl:value-of select="'biota'"/>
			</xsl:when>
			<xsl:when test="$input='boundaries'">
				<xsl:value-of select="'boundaries'"/>
			</xsl:when>
			<xsl:when test="$input='climatologymeteorologyatmosphere'">
				<xsl:value-of select="'climatologyMeteorologyAtmosphere'"/>
			</xsl:when>
			<xsl:when test="$input='economy'">
				<xsl:value-of select="'economy'"/>
			</xsl:when>
			<xsl:when test="$input='elevation'">
				<xsl:value-of select="'elevation'"/>
			</xsl:when>
			<xsl:when test="$input='environment'">
				<xsl:value-of select="'environment'"/>
			</xsl:when>
			<xsl:when test="$input='geoscientificinformation'">
				<xsl:value-of select="'geoscientificInformation'"/>
			</xsl:when>
			<xsl:when test="$input='health'">
				<xsl:value-of select="'health'"/>
			</xsl:when>
			<xsl:when test="$input='imagerybasemapsearthcover'">
				<xsl:value-of select="'imageryBaseMapsEarthCover'"/>
			</xsl:when>
			<xsl:when test="$input='intelligencemilitary'">
				<xsl:value-of select="'intelligenceMilitary'"/>
			</xsl:when>
			<xsl:when test="$input='inlandwaters'">
				<xsl:value-of select="'inlandWaters'"/>
			</xsl:when>
			<xsl:when test="$input='location'">
				<xsl:value-of select="'location'"/>
			</xsl:when>
			<xsl:when test="$input='oceans'">
				<xsl:value-of select="'oceans'"/>
			</xsl:when>
			<xsl:when test="$input='planningcadastre'">
				<xsl:value-of select="'planningCadastre'"/>
			</xsl:when>
			<xsl:when test="$input='society'">
				<xsl:value-of select="'society'"/>
			</xsl:when>
			<xsl:when test="$input='structure'">
				<xsl:value-of select="'structure'"/>
			</xsl:when>
			<xsl:when test="$input='transportation'">
				<xsl:value-of select="'transportation'"/>
			</xsl:when>
			<xsl:when test="$input='utilitiescommunication'">
				<xsl:value-of select="'utilitiesCommunication'"/>
			</xsl:when>
			<xsl:when test="$input='ocean'">
				<xsl:value-of select="'oceans'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf18_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'dvd'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'dvdRom'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'3halfInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'5quarterInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'7trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'9trackType'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'9trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'3480Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'3490Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'3580Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'4mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'8mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'1quarterInchCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'digitalLinearTape'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'onLine'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'satellite'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'telephoneLink'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'hardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='CD ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='CDROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf19_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'014'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'015'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'016'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'017'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'018'"/>
			</xsl:when>
			<xsl:when test="$input='CD ROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='CDROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf20_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'cpio'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'tar'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'highSierra'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'iso9660'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf21_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:output method="xml" encoding="UTF-8" indent="yes"/>
	<xsl:function name="grp:key0acecdb0">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/srcused">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key0d4338f0">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/origin">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:template match="/">
		<gmi:MI_Metadata>
			<xsl:attribute name="xsi:schemaLocation" separator=" ">
				<xsl:sequence select="'http://www.isotc211.org/2005/gmi Q:/users/mize.jacqueline/ISO/ISOngdc/schema/gmi/gmi.xsd'"/>
			</xsl:attribute>
			<xsl:variable name="var1_instance" as="node()" select="."/>
			<gmd:fileIdentifier>
				<xsl:for-each select="$var1_instance/metadata">
					<gco:CharacterString>
						<xsl:sequence select="fn:concat('gov.noaa.nodc.ncddc.', fn:substring-before(fn:base-uri(.), '.xml'))"/>
					</gco:CharacterString>
				</xsl:for-each>
			</gmd:fileIdentifier>
			<gmd:language>
				<gco:CharacterString>
					<xsl:sequence select="'eng; USA'"/>
				</gco:CharacterString>
			</gmd:language>
			<gmd:characterSet>
				<gmd:MD_CharacterSetCode>
					<xsl:attribute name="codeList">
						<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CharacterSetCode'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeListValue">
						<xsl:sequence select="xs:string(xs:anyURI('utf8'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeSpace">
						<xsl:sequence select="xs:string(xs:anyURI('004'))"/>
					</xsl:attribute>
					<xsl:sequence select="'utf8'"/>
				</gmd:MD_CharacterSetCode>
			</gmd:characterSet>
			<gmd:hierarchyLevel>
				<gmd:MD_ScopeCode>
					<xsl:attribute name="codeList">
						<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeListValue">
						<xsl:sequence select="xs:string(xs:anyURI('dataset'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeSpace">
						<xsl:sequence select="xs:string(xs:anyURI('005'))"/>
					</xsl:attribute>
					<xsl:sequence select="'dataset'"/>
				</gmd:MD_ScopeCode>
			</gmd:hierarchyLevel>
			<gmd:contact>
				<gmd:CI_ResponsibleParty>
					<xsl:variable name="var5_map_select_metadata" as="xs:string?">
						<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
							<xsl:sequence select="xs:string(.)"/>
						</xsl:for-each>
					</xsl:variable>
					<xsl:variable name="var4_cond_result_exists" as="xs:string?">
						<xsl:choose>
							<xsl:when test="fn:exists($var5_map_select_metadata)">
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntper">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:if test="fn:exists($var4_cond_result_exists)">
						<gmd:individualName>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space($var4_cond_result_exists)"/>
							</gco:CharacterString>
						</gmd:individualName>
					</xsl:if>
					<xsl:variable name="var14_map_select_metadata" as="xs:string?">
						<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
							<xsl:sequence select="xs:string(.)"/>
						</xsl:for-each>
					</xsl:variable>
					<xsl:variable name="var13_cond_result_exists" as="xs:string?">
						<xsl:choose>
							<xsl:when test="fn:exists($var14_map_select_metadata)">
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntorg">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:if test="fn:exists($var13_cond_result_exists)">
						<gmd:organisationName>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space($var13_cond_result_exists)"/>
							</gco:CharacterString>
						</gmd:organisationName>
					</xsl:if>
					<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntpos">
						<gmd:positionName>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
							</gco:CharacterString>
						</gmd:positionName>
					</xsl:for-each>
					<gmd:contactInfo>
						<gmd:CI_Contact>
							<gmd:phone>
								<gmd:CI_Telephone>
									<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
										<xsl:variable name="var26_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
										<gmd:voice>
											<gco:CharacterString>
												<xsl:sequence select="$var26_cur_result_groupby"/>
											</gco:CharacterString>
										</gmd:voice>
									</xsl:for-each-group>
									<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
										<xsl:variable name="var30_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
										<gmd:facsimile>
											<gco:CharacterString>
												<xsl:sequence select="$var30_cur_result_groupby"/>
											</gco:CharacterString>
										</gmd:facsimile>
									</xsl:for-each-group>
								</gmd:CI_Telephone>
							</gmd:phone>
							<xsl:for-each select="$var1_instance/metadata">
								<xsl:variable name="var32_metadata" as="node()" select="."/>
								<xsl:for-each select="metainfo/metc/cntinfo/cntaddr">
									<gmd:address>
										<gmd:CI_Address>
											<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var38_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:deliveryPoint>
													<gco:CharacterString>
														<xsl:sequence select="$var38_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:deliveryPoint>
											</xsl:for-each-group>
											<gmd:city>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(city))"/>
												</gco:CharacterString>
											</gmd:city>
											<gmd:administrativeArea>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(state))"/>
												</gco:CharacterString>
											</gmd:administrativeArea>
											<gmd:postalCode>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(postal))"/>
												</gco:CharacterString>
											</gmd:postalCode>
											<xsl:for-each select="country">
												<gmd:country>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:country>
											</xsl:for-each>
											<xsl:for-each-group select="$var32_metadata/metainfo/metc/cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var44_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:electronicMailAddress>
													<gco:CharacterString>
														<xsl:sequence select="$var44_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:electronicMailAddress>
											</xsl:for-each-group>
										</gmd:CI_Address>
									</gmd:address>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/hours">
								<gmd:hoursOfService>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:hoursOfService>
							</xsl:for-each>
							<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntinst">
								<gmd:contactInstructions>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:contactInstructions>
							</xsl:for-each>
						</gmd:CI_Contact>
					</gmd:contactInfo>
					<gmd:role>
						<gmd:CI_RoleCode>
							<xsl:attribute name="codeList">
								<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
							</xsl:attribute>
							<xsl:attribute name="codeListValue">
								<xsl:sequence select="xs:string(xs:anyURI('pointOfContact'))"/>
							</xsl:attribute>
							<xsl:attribute name="codeSpace">
								<xsl:sequence select="xs:string(xs:anyURI('007'))"/>
							</xsl:attribute>
							<xsl:sequence select="'pointOfContact'"/>
						</gmd:CI_RoleCode>
					</gmd:role>
				</gmd:CI_ResponsibleParty>
			</gmd:contact>
			<gmd:dateStamp>
				<xsl:for-each select="$var1_instance/metadata">
					<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unpublished'))">
						<xsl:attribute name="gco:nilReason">
							<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd))))))"/>
						</xsl:attribute>
					</xsl:if>
				</xsl:for-each>
				<xsl:for-each select="$var1_instance/metadata">
					<xsl:variable name="var55_cond_result_logicalor" as="xs:string?">
						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'present')))">
							<xsl:variable name="var60_map_result_distinctvalues" as="xs:string*">
								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
									<xsl:choose>
										<xsl:when test="fn:ends-with(., '-')">
											<xsl:if test="fn:ends-with(., '-')">
												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
												</xsl:if>
											</xsl:if>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="."/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var59_map_result_distinctvalues" as="xs:string*">
								<xsl:for-each select="fn:distinct-values($var60_map_result_distinctvalues)">
									<xsl:variable name="var65_cond_result_endswith" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
													</xsl:if>
												</xsl:if>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var65_cond_result_endswith)">
										<xsl:sequence select="$var65_cond_result_endswith"/>
									</xsl:if>
								</xsl:for-each>
							</xsl:variable>
							<xsl:if test="fn:exists($var59_map_result_distinctvalues)">
								<xsl:sequence select="fn:string-join($var59_map_result_distinctvalues, ' ')"/>
							</xsl:if>
						</xsl:if>
					</xsl:variable>
					<xsl:for-each select="$var55_cond_result_logicalor">
						<gco:Date>
							<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
						</gco:Date>
					</xsl:for-each>
				</xsl:for-each>
			</gmd:dateStamp>
			<gmd:metadataStandardName>
				<gco:CharacterString>
					<xsl:sequence select="'ISO 19115-2 Geographic Information - Metadata - Part 2: Extensions for Imagery and Gridded Data'"/>
				</gco:CharacterString>
			</gmd:metadataStandardName>
			<gmd:metadataStandardVersion>
				<gco:CharacterString>
					<xsl:sequence select="'ISO 19115-2:2009(E)'"/>
				</gco:CharacterString>
			</gmd:metadataStandardVersion>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var72_metadata" as="node()" select="."/>
				<xsl:for-each select="spdoinfo">
					<gmd:spatialRepresentationInfo>
						<xsl:for-each select="rastinfo">
							<xsl:variable name="var76_rastinfo" as="node()" select="."/>
							<gmd:MD_GridSpatialRepresentation>
								<gmd:numberOfDimensions>
									<xsl:variable name="var78_cond_result_exists" as="xs:decimal?" select="(if (fn:exists(rowcount)) then xs:decimal(1) else ())"/>
									<xsl:if test="fn:exists($var78_cond_result_exists)">
										<xsl:variable name="var79_cond_result_exists" as="xs:decimal?" select="(if (fn:exists(colcount)) then xs:decimal(1) else ())"/>
										<xsl:if test="fn:exists($var79_cond_result_exists)">
											<xsl:variable name="var80_cond_result_exists" as="xs:decimal?" select="(if (fn:exists(vrtcount)) then xs:decimal(1) else ())"/>
											<xsl:if test="fn:exists($var80_cond_result_exists)">
												<gco:Integer>
													<xsl:sequence select="xs:string(xs:integer((($var78_cond_result_exists + $var79_cond_result_exists) + $var80_cond_result_exists)))"/>
												</gco:Integer>
											</xsl:if>
										</xsl:if>
									</xsl:if>
								</gmd:numberOfDimensions>
								<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<xsl:variable name="var83_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/rowcount)) then 'row' else ())"/>
												<xsl:if test="fn:exists($var83_cond_result_exists)">
													<gmd:MD_DimensionNameTypeCode>
														<xsl:variable name="var84_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/rowcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
														<xsl:if test="fn:exists($var84_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var84_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var83_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var85_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/rowcount)) then '001' else ())"/>
														<xsl:if test="fn:exists($var85_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var85_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var83_cond_result_exists"/>
													</gmd:MD_DimensionNameTypeCode>
												</xsl:if>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var76_rastinfo/rowcount">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(xs:positiveInteger(.)))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:for-each>
								<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<xsl:variable name="var90_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/colcount)) then 'column' else ())"/>
												<xsl:if test="fn:exists($var90_cond_result_exists)">
													<gmd:MD_DimensionNameTypeCode>
														<xsl:variable name="var91_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/colcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
														<xsl:if test="fn:exists($var91_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var91_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var90_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var92_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/colcount)) then '002' else ())"/>
														<xsl:if test="fn:exists($var92_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var92_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var90_cond_result_exists"/>
													</gmd:MD_DimensionNameTypeCode>
												</xsl:if>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var76_rastinfo/colcount">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(xs:positiveInteger(.)))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:for-each>
								<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<xsl:variable name="var97_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/vrtcount)) then 'vertical' else ())"/>
												<xsl:if test="fn:exists($var97_cond_result_exists)">
													<gmd:MD_DimensionNameTypeCode>
														<xsl:variable name="var98_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/vrtcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
														<xsl:if test="fn:exists($var98_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var98_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var97_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var99_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/vrtcount)) then '003' else ())"/>
														<xsl:if test="fn:exists($var99_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var99_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var97_cond_result_exists"/>
													</gmd:MD_DimensionNameTypeCode>
												</xsl:if>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var76_rastinfo/vrtcount">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(xs:positiveInteger(.)))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:for-each>
								<gmd:cellGeometry>
									<xsl:variable name="var105_result_vmf1_inputtoresult" as="xs:string?">
										<xsl:call-template name="vmf:vmf1_inputtoresult">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(rasttype)))"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:variable name="var102_cond_result_exists" as="xs:string?" select="(if (fn:exists($var105_result_vmf1_inputtoresult)) then $var105_result_vmf1_inputtoresult else ())"/>
									<xsl:if test="fn:exists($var102_cond_result_exists)">
										<gmd:MD_CellGeometryCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI($var102_cond_result_exists))"/>
											</xsl:attribute>
											<xsl:variable name="var104_result_vmf2_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf2_inputtoresult">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(rasttype)))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:variable name="var103_cond_result_exists" as="xs:string?" select="(if (fn:exists($var104_result_vmf2_inputtoresult)) then $var104_result_vmf2_inputtoresult else ())"/>
											<xsl:if test="fn:exists($var103_cond_result_exists)">
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI($var103_cond_result_exists))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="$var102_cond_result_exists"/>
										</gmd:MD_CellGeometryCode>
									</xsl:if>
								</gmd:cellGeometry>
								<gmd:transformationParameterAvailability>
									<xsl:variable name="var106_cond_result_exists" as="xs:string?" select="(if (fn:exists(rowcount)) then 'unknown' else ())"/>
									<xsl:if test="fn:exists($var106_cond_result_exists)">
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string($var106_cond_result_exists))"/>
										</xsl:attribute>
									</xsl:if>
								</gmd:transformationParameterAvailability>
							</gmd:MD_GridSpatialRepresentation>
						</xsl:for-each>
						<xsl:for-each select="ptvctinf">
							<xsl:variable name="var107_ptvctinf" as="node()" select="."/>
							<gmd:MD_VectorSpatialRepresentation>
								<xsl:for-each select="vpfterm">
									<gmd:topologyLevel>
										<gmd:MD_TopologyLevelCode>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(fn:string(vpflevel))))"/>
											</xsl:attribute>
										</gmd:MD_TopologyLevelCode>
									</gmd:topologyLevel>
								</xsl:for-each>
								<gmd:geometricObjects>
									<gmd:MD_GeometricObjects>
										<gmd:geometricObjectType>
											<xsl:variable name="var134_map_select_sdtsterm" as="xs:string*">
												<xsl:for-each select="sdtsterm">
													<xsl:sequence select="fn:string(sdtstype)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var111_cond_result_exists" as="xs:string?">
												<xsl:if test="fn:exists($var134_map_select_sdtsterm)">
													<xsl:variable name="var136_cond_result_exists" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:exists($var134_map_select_sdtsterm)">
																<xsl:variable name="var142_map_select_sdtsterm" as="xs:string*">
																	<xsl:for-each select="sdtsterm">
																		<xsl:if test="fn:exists($var134_map_select_sdtsterm)">
																			<xsl:sequence select="fn:string(sdtstype)"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var142_map_select_sdtsterm)">
																	<xsl:sequence select="fn:string-join($var142_map_select_sdtsterm, ' ')"/>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="vpfterm">
																	<xsl:sequence select="fn:string(vpflevel)"/>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var136_cond_result_exists">
														<xsl:variable name="var139_result_vmf3_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf3_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:if test="fn:exists($var139_result_vmf3_inputtoresult)">
															<xsl:sequence select="$var139_result_vmf3_inputtoresult"/>
														</xsl:if>
													</xsl:for-each>
												</xsl:if>
											</xsl:variable>
											<xsl:if test="fn:exists($var111_cond_result_exists)">
												<gmd:MD_GeometricObjectTypeCode>
													<xsl:variable name="var112_map_select_vpfterm" as="xs:string?">
														<xsl:for-each select="vpfterm">
															<xsl:sequence select="fn:string(vpflevel)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var113_map_select_sdtsterm" as="xs:string*">
														<xsl:for-each select="sdtsterm">
															<xsl:sequence select="fn:string(sdtstype)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists((if ((fn:exists($var113_map_select_sdtsterm) or fn:exists($var112_map_select_vpfterm))) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode' else ()))">
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI(fn:string((if ((fn:exists($var113_map_select_sdtsterm) or fn:exists($var112_map_select_vpfterm))) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode' else ()))))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI(fn:string($var111_cond_result_exists)))"/>
													</xsl:attribute>
													<xsl:variable name="var119_map_select_sdtsterm" as="xs:string*">
														<xsl:for-each select="sdtsterm">
															<xsl:sequence select="fn:string(sdtstype)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var118_cond_result_exists" as="xs:string?">
														<xsl:if test="fn:exists($var119_map_select_sdtsterm)">
															<xsl:variable name="var121_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:exists($var119_map_select_sdtsterm)">
																		<xsl:variable name="var127_map_select_sdtsterm" as="xs:string*">
																			<xsl:for-each select="sdtsterm">
																				<xsl:if test="fn:exists($var119_map_select_sdtsterm)">
																					<xsl:sequence select="fn:string(sdtstype)"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var127_map_select_sdtsterm)">
																			<xsl:sequence select="fn:string-join($var127_map_select_sdtsterm, ' ')"/>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="vpfterm">
																			<xsl:sequence select="fn:string(vpflevel)"/>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var121_cond_result_exists">
																<xsl:variable name="var124_result_vmf4_inputtoresult" as="xs:string?">
																	<xsl:call-template name="vmf:vmf4_inputtoresult">
																		<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:if test="fn:exists($var124_result_vmf4_inputtoresult)">
																	<xsl:sequence select="$var124_result_vmf4_inputtoresult"/>
																</xsl:if>
															</xsl:for-each>
														</xsl:if>
													</xsl:variable>
													<xsl:if test="fn:exists($var118_cond_result_exists)">
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI(fn:string($var118_cond_result_exists)))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:sequence select="fn:string($var111_cond_result_exists)"/>
												</gmd:MD_GeometricObjectTypeCode>
											</xsl:if>
										</gmd:geometricObjectType>
										<gmd:geometricObjectCount>
											<xsl:variable name="var152_map_select_sdtsterm" as="xs:string*">
												<xsl:for-each select="sdtsterm/ptvctcnt">
													<xsl:sequence select="xs:string(xs:integer(.))"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var149_cond_result_exists" as="xs:string*">
												<xsl:choose>
													<xsl:when test="fn:exists($var152_map_select_sdtsterm)">
														<xsl:for-each select="sdtsterm/ptvctcnt">
															<xsl:sequence select="xs:string(xs:integer(.))"/>
														</xsl:for-each>
													</xsl:when>
													<xsl:otherwise>
														<xsl:for-each select="vpfterm/vpfinfo/ptvctcnt">
															<xsl:sequence select="xs:string(xs:integer(.))"/>
														</xsl:for-each>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:for-each select="$var149_cond_result_exists">
												<gco:Integer>
													<xsl:sequence select="xs:string(xs:integer(.))"/>
												</gco:Integer>
											</xsl:for-each>
										</gmd:geometricObjectCount>
									</gmd:MD_GeometricObjects>
								</gmd:geometricObjects>
							</gmd:MD_VectorSpatialRepresentation>
						</xsl:for-each>
					</gmd:spatialRepresentationInfo>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var160_metadata" as="node()" select="."/>
				<xsl:for-each select="spref/horizsys/geograph">
					<gmd:spatialRepresentationInfo>
						<gmd:MD_GridSpatialRepresentation>
							<gmd:numberOfDimensions>
								<gco:Integer>
									<xsl:sequence select="xs:string(xs:integer(xs:decimal(2)))"/>
								</gco:Integer>
							</gmd:numberOfDimensions>
							<gmd:axisDimensionProperties>
								<gmd:MD_Dimension>
									<gmd:dimensionName>
										<gmd:MD_DimensionNameTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('column'))"/>
											</xsl:attribute>
											<xsl:sequence select="'column'"/>
										</gmd:MD_DimensionNameTypeCode>
									</gmd:dimensionName>
									<gmd:dimensionSize>
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string('unknown'))"/>
										</xsl:attribute>
									</gmd:dimensionSize>
									<gmd:resolution>
										<gco:Scale>
											<xsl:variable name="var164_result_vmf5_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf5_inputtoresult">
													<xsl:with-param name="input" select="xs:string(xs:token(geogunit))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:if test="fn:exists($var164_result_vmf5_inputtoresult)">
												<xsl:attribute name="uom">
													<xsl:sequence select="xs:string(xs:string($var164_result_vmf5_inputtoresult))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="xs:string(xs:double(longres))"/>
										</gco:Scale>
									</gmd:resolution>
								</gmd:MD_Dimension>
							</gmd:axisDimensionProperties>
							<gmd:axisDimensionProperties>
								<gmd:MD_Dimension>
									<gmd:dimensionName>
										<gmd:MD_DimensionNameTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('row'))"/>
											</xsl:attribute>
											<xsl:sequence select="'row'"/>
										</gmd:MD_DimensionNameTypeCode>
									</gmd:dimensionName>
									<gmd:dimensionSize>
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string('unknown'))"/>
										</xsl:attribute>
									</gmd:dimensionSize>
									<gmd:resolution>
										<gco:Scale>
											<xsl:variable name="var165_result_vmf5_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf5_inputtoresult">
													<xsl:with-param name="input" select="xs:string(xs:token(geogunit))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:if test="fn:exists($var165_result_vmf5_inputtoresult)">
												<xsl:attribute name="uom">
													<xsl:sequence select="xs:string(xs:string($var165_result_vmf5_inputtoresult))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="xs:string(xs:double(latres))"/>
										</gco:Scale>
									</gmd:resolution>
								</gmd:MD_Dimension>
							</gmd:axisDimensionProperties>
							<gmd:cellGeometry>
								<xsl:variable name="var166_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="fn:exists($var160_metadata/spdoinfo/rastinfo/rasttype)">
											<xsl:for-each select="$var160_metadata/spdoinfo/rastinfo">
												<xsl:variable name="var176_result_vmf1_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:vmf1_inputtoresult">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:token(rasttype))))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:if test="fn:exists($var176_result_vmf1_inputtoresult)">
													<xsl:sequence select="$var176_result_vmf1_inputtoresult"/>
												</xsl:if>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="''"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var166_cond_result_exists)">
									<gmd:MD_CellGeometryCode>
										<xsl:attribute name="codeList">
											<xsl:variable name="var167_cond_result_exists" as="xs:string" select="(if (fn:exists($var160_metadata/spdoinfo/rastinfo/rasttype)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode' else '')"/>
											<xsl:sequence select="xs:string(xs:anyURI($var167_cond_result_exists))"/>
										</xsl:attribute>
										<xsl:attribute name="codeListValue">
											<xsl:sequence select="xs:string(xs:anyURI($var166_cond_result_exists))"/>
										</xsl:attribute>
										<xsl:variable name="var168_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="fn:exists($var160_metadata/spdoinfo/rastinfo/rasttype)">
													<xsl:for-each select="$var160_metadata/spdoinfo/rastinfo">
														<xsl:variable name="var172_result_vmf2_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf2_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:token(rasttype))))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:if test="fn:exists($var172_result_vmf2_inputtoresult)">
															<xsl:sequence select="$var172_result_vmf2_inputtoresult"/>
														</xsl:if>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="''"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:if test="fn:exists($var168_cond_result_exists)">
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI($var168_cond_result_exists))"/>
											</xsl:attribute>
										</xsl:if>
										<xsl:sequence select="$var166_cond_result_exists"/>
									</gmd:MD_CellGeometryCode>
								</xsl:if>
							</gmd:cellGeometry>
							<gmd:transformationParameterAvailability>
								<gco:Boolean>
									<xsl:sequence select="xs:string(((('0' != 'false') and ('false' != 'false')) and fn:boolean('false')))"/>
								</gco:Boolean>
							</gmd:transformationParameterAvailability>
						</gmd:MD_GridSpatialRepresentation>
					</gmd:spatialRepresentationInfo>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spdoinfo">
				<gmd:referenceSystemInfo>
					<gmd:MD_ReferenceSystem>
						<xsl:for-each select="indspref">
							<gmd:referenceSystemIdentifier>
								<gmd:RS_Identifier>
									<gmd:code>
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string('unknown'))"/>
										</xsl:attribute>
									</gmd:code>
									<gmd:codeSpace>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(.)"/>
										</gco:CharacterString>
									</gmd:codeSpace>
								</gmd:RS_Identifier>
							</gmd:referenceSystemIdentifier>
						</xsl:for-each>
					</gmd:MD_ReferenceSystem>
				</gmd:referenceSystemInfo>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/planar/mapproj">
				<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'albers')) then 'https://www.ngdc.noaa.gov/docucomp/597772c0-751c-11e1-b0c4-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'albers')) then 'https://www.ngdc.noaa.gov/docucomp/597772c0-751c-11e1-b0c4-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'albers')) then 'NAD83 / Conus Albers' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'albers')) then 'NAD83 / Conus Albers' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/planar/mapproj">
				<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'mercator')) then 'https://www.ngdc.noaa.gov/docucomp/895cc120-95ed-11e0-aa80-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'mercator')) then 'https://www.ngdc.noaa.gov/docucomp/895cc120-95ed-11e0-aa80-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'mercator')) then 'WGS 84 / World Mercator' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'mercator')) then 'WGS 84 / World Mercator' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/geodetic/horizdn">
				<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '84')) then 'https://www.ngdc.noaa.gov/docucomp/2504d000-8345-11e1-b0c4-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(xs:string(xs:string(.)), '84')) then 'https://www.ngdc.noaa.gov/docucomp/2504d000-8345-11e1-b0c4-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '84')) then 'World Geodetic System 1984' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(xs:string(xs:string(.)), '84')) then 'World Geodetic System 1984' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/geodetic/horizdn">
				<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '83')) then 'https://www.ngdc.noaa.gov/docucomp/65f8b220-95ed-11e0-aa80-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(xs:string(xs:string(.)), '83')) then 'https://www.ngdc.noaa.gov/docucomp/65f8b220-95ed-11e0-aa80-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '83')) then 'North American Datum 1983' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(xs:string(xs:string(.)), '83')) then 'North American Datum 1983' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/geodetic/horizdn">
				<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '27')) then 'https://www.ngdc.noaa.gov/docucomp/32c8e7d0-95ed-11e0-aa80-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(xs:string(xs:string(.)), '27')) then 'https://www.ngdc.noaa.gov/docucomp/32c8e7d0-95ed-11e0-aa80-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '27')) then 'North American Datum 1927' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(xs:string(xs:string(.)), '27')) then 'North American Datum 1927' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/geodetic">
				<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(ellips)), '1866')) then 'https://www.ngdc.noaa.gov/docucomp/a75c0b90-95ed-11e0-aa80-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(xs:string(xs:string(ellips)), '1866')) then 'https://www.ngdc.noaa.gov/docucomp/a75c0b90-95ed-11e0-aa80-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(ellips)), '1866')) then 'Clarke 1866' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(xs:string(xs:string(ellips)), '1866')) then 'Clarke 1866' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/geodetic">
				<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(ellips)), '80')) then 'https://www.ngdc.noaa.gov/docucomp/c3895520-95ed-11e0-aa80-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(xs:string(xs:string(ellips)), '80')) then 'https://www.ngdc.noaa.gov/docucomp/c3895520-95ed-11e0-aa80-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(ellips)), '80')) then 'Geodetic Reference System 1980' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(xs:string(xs:string(ellips)), '80')) then 'Geodetic Reference System 1980' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var195_metadata" as="node()" select="."/>
				<gmd:identificationInfo>
					<gmd:MD_DataIdentification>
						<gmd:citation>
							<gmd:CI_Citation>
								<gmd:title>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(idinfo/citation/citeinfo/title))"/>
									</gco:CharacterString>
								</gmd:title>
								<gmd:date>
									<gmd:CI_Date>
										<gmd:date>
											<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unpublished'))">
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate)))))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:variable name="var198_cond_result_logicalor" as="xs:string?">
												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'present')))">
													<xsl:variable name="var203_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
															<xsl:choose>
																<xsl:when test="fn:ends-with(., '-')">
																	<xsl:if test="fn:ends-with(., '-')">
																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="."/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var202_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var203_map_result_distinctvalues)">
															<xsl:variable name="var208_cond_result_endswith" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="."/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var208_cond_result_endswith)">
																<xsl:sequence select="$var208_cond_result_endswith"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var202_map_result_distinctvalues)">
														<xsl:sequence select="fn:string-join($var202_map_result_distinctvalues, ' ')"/>
													</xsl:if>
												</xsl:if>
											</xsl:variable>
											<xsl:for-each select="$var198_cond_result_logicalor">
												<gco:Date>
													<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
												</gco:Date>
											</xsl:for-each>
											<xsl:variable name="var216_cond_result_logicalor" as="xs:string?">
												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'present')))">
													<xsl:variable name="var249_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
															<xsl:choose>
																<xsl:when test="fn:ends-with(., '-')">
																	<xsl:if test="fn:ends-with(., '-')">
																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="."/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var248_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var249_map_result_distinctvalues)">
															<xsl:variable name="var254_cond_result_endswith" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="."/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var254_cond_result_endswith)">
																<xsl:sequence select="$var254_cond_result_endswith"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var248_map_result_distinctvalues)">
														<xsl:sequence select="fn:string-join($var248_map_result_distinctvalues, ' ')"/>
													</xsl:if>
												</xsl:if>
											</xsl:variable>
											<xsl:for-each select="$var216_cond_result_logicalor">
												<xsl:variable name="var217_cur_cond_result_logicalor" as="xs:string" select="."/>
												<xsl:variable name="var219_map_select_pubtime" as="xs:string?">
													<xsl:for-each select="$var195_metadata/idinfo/citation/citeinfo/pubtime">
														<xsl:variable name="var246_result_vmf6_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf6_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:variable name="var245_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var246_result_vmf6_inputtoresult)) then (if (fn:contains($var246_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
														<xsl:if test="not(fn:exists($var245_cond_result_exists))">
															<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
														</xsl:if>
													</xsl:for-each>
												</xsl:variable>
												<xsl:for-each select="fn:distinct-values($var219_map_select_pubtime)">
													<xsl:variable name="var224_cond_result_endswith" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:ends-with(., ':')">
																<xsl:if test="fn:ends-with(., ':')">
																	<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																		<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																	</xsl:if>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:sequence select="."/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:if test="fn:exists($var224_cond_result_endswith)">
														<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith))), 'un'))">
															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith)))))) then 'T' else ()))">
																<gco:DateTime>
																	<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var217_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith)))))))"/>
																</gco:DateTime>
															</xsl:if>
														</xsl:if>
													</xsl:if>
												</xsl:for-each>
											</xsl:for-each>
										</gmd:date>
										<gmd:dateType>
											<gmd:CI_DateTypeCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
												</xsl:attribute>
												<xsl:sequence select="'publication'"/>
											</gmd:CI_DateTypeCode>
										</gmd:dateType>
									</gmd:CI_Date>
								</gmd:date>
								<xsl:for-each select="idinfo/citation/citeinfo/edition">
									<gmd:edition>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(.)"/>
										</gco:CharacterString>
									</gmd:edition>
								</xsl:for-each>
								<xsl:for-each select="distinfo/resdesc">
									<gmd:identifier>
										<gmd:MD_Identifier>
											<gmd:code>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(.)"/>
												</gco:CharacterString>
											</gmd:code>
										</gmd:MD_Identifier>
									</gmd:identifier>
								</xsl:for-each>
								<xsl:for-each-group select="idinfo/citation/citeinfo/origin" group-by="fn:normalize-space(xs:string(xs:string(.)))">
									<xsl:variable name="var267_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
									<gmd:citedResponsibleParty>
										<gmd:CI_ResponsibleParty>
											<gmd:organisationName>
												<gco:CharacterString>
													<xsl:sequence select="$var267_cur_result_groupby"/>
												</gco:CharacterString>
											</gmd:organisationName>
											<gmd:role>
												<gmd:CI_RoleCode>
													<xsl:attribute name="codeList">
														<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI('originator'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
													</xsl:attribute>
													<xsl:sequence select="'originator'"/>
												</gmd:CI_RoleCode>
											</gmd:role>
										</gmd:CI_ResponsibleParty>
									</gmd:citedResponsibleParty>
								</xsl:for-each-group>
								<xsl:for-each select="idinfo/citation/citeinfo/pubinfo">
									<gmd:citedResponsibleParty>
										<gmd:CI_ResponsibleParty>
											<gmd:organisationName>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(publish)"/>
												</gco:CharacterString>
											</gmd:organisationName>
											<gmd:contactInfo>
												<gmd:CI_Contact>
													<gmd:address>
														<gmd:CI_Address>
															<gmd:city>
																<gco:CharacterString>
																	<xsl:sequence select="fn:substring-before(xs:string(pubplace), ',')"/>
																</gco:CharacterString>
															</gmd:city>
															<gmd:administrativeArea>
																<gco:CharacterString>
																	<xsl:sequence select="fn:substring-after(xs:string(pubplace), ',')"/>
																</gco:CharacterString>
															</gmd:administrativeArea>
														</gmd:CI_Address>
													</gmd:address>
												</gmd:CI_Contact>
											</gmd:contactInfo>
											<gmd:role>
												<gmd:CI_RoleCode>
													<xsl:attribute name="codeList">
														<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI('publisher'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI('010'))"/>
													</xsl:attribute>
													<xsl:sequence select="'publisher'"/>
												</gmd:CI_RoleCode>
											</gmd:role>
										</gmd:CI_ResponsibleParty>
									</gmd:citedResponsibleParty>
								</xsl:for-each>
								<gmd:presentationForm>
									<xsl:variable name="var271_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="$var195_metadata/idinfo/citation/citeinfo/geoform">
												<xsl:for-each select="idinfo/citation/citeinfo/geoform">
													<xsl:variable name="var282_result_vmf7_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf7_inputtoresult">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var282_result_vmf7_inputtoresult)">
														<xsl:sequence select="$var282_result_vmf7_inputtoresult"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:for-each select="idinfo/citation/citeinfo/geoform">
													<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
												</xsl:for-each>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var271_cond_result_exists)">
										<gmd:CI_PresentationFormCode>
											<xsl:variable name="var272_cond_result_exists" as="xs:string?" select="(if (fn:exists(idinfo/citation/citeinfo/geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode' else ())"/>
											<xsl:if test="fn:exists($var272_cond_result_exists)">
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI($var272_cond_result_exists))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI($var271_cond_result_exists))"/>
											</xsl:attribute>
											<xsl:variable name="var273_cond_result_exists" as="xs:string?">
												<xsl:if test="$var195_metadata/idinfo/citation/citeinfo/geoform">
													<xsl:for-each select="idinfo/citation/citeinfo/geoform">
														<xsl:variable name="var277_result_vmf8_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf8_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:if test="fn:exists($var277_result_vmf8_inputtoresult)">
															<xsl:sequence select="$var277_result_vmf8_inputtoresult"/>
														</xsl:if>
													</xsl:for-each>
												</xsl:if>
											</xsl:variable>
											<xsl:if test="fn:exists($var273_cond_result_exists)">
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI($var273_cond_result_exists))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="$var271_cond_result_exists"/>
										</gmd:CI_PresentationFormCode>
									</xsl:if>
								</gmd:presentationForm>
								<xsl:for-each select="idinfo/citation/citeinfo/serinfo">
									<gmd:series>
										<gmd:CI_Series>
											<gmd:name>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(sername)"/>
												</gco:CharacterString>
											</gmd:name>
											<gmd:issueIdentification>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(issue)"/>
												</gco:CharacterString>
											</gmd:issueIdentification>
										</gmd:CI_Series>
									</gmd:series>
								</xsl:for-each>
								<xsl:for-each select="idinfo/citation/citeinfo/othercit">
									<gmd:otherCitationDetails>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(.)"/>
										</gco:CharacterString>
									</gmd:otherCitationDetails>
								</xsl:for-each>
							</gmd:CI_Citation>
						</gmd:citation>
						<gmd:abstract>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space(xs:string(idinfo/descript/abstract))"/>
							</gco:CharacterString>
						</gmd:abstract>
						<gmd:purpose>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space(xs:string(idinfo/descript/purpose))"/>
							</gco:CharacterString>
						</gmd:purpose>
						<xsl:for-each-group select="idinfo/datacred" group-by="fn:normalize-space(xs:string(.))">
							<xsl:variable name="var291_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:credit>
								<gco:CharacterString>
									<xsl:sequence select="$var291_cur_result_groupby"/>
								</gco:CharacterString>
							</gmd:credit>
						</xsl:for-each-group>
						<gmd:status>
							<xsl:variable name="var296_result_vmf9_inputtoresult" as="xs:string?">
								<xsl:call-template name="vmf:vmf9_inputtoresult">
									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(idinfo/status/progress)))"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:variable name="var293_cond_result_exists" as="xs:string?" select="(if (fn:exists($var296_result_vmf9_inputtoresult)) then $var296_result_vmf9_inputtoresult else ())"/>
							<xsl:if test="fn:exists($var293_cond_result_exists)">
								<gmd:MD_ProgressCode>
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:sequence select="xs:string(xs:anyURI($var293_cond_result_exists))"/>
									</xsl:attribute>
									<xsl:variable name="var295_result_vmf10_inputtoresult" as="xs:string?">
										<xsl:call-template name="vmf:vmf10_inputtoresult">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(idinfo/status/progress)))"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:variable name="var294_cond_result_exists" as="xs:string?" select="(if (fn:exists($var295_result_vmf10_inputtoresult)) then $var295_result_vmf10_inputtoresult else ())"/>
									<xsl:if test="fn:exists($var294_cond_result_exists)">
										<xsl:attribute name="codeSpace">
											<xsl:sequence select="xs:string(xs:anyURI($var294_cond_result_exists))"/>
										</xsl:attribute>
									</xsl:if>
									<xsl:sequence select="$var293_cond_result_exists"/>
								</gmd:MD_ProgressCode>
							</xsl:if>
						</gmd:status>
						<xsl:for-each select="idinfo/ptcontac">
							<xsl:variable name="var297_ptcontac" as="node()" select="."/>
							<gmd:pointOfContact>
								<gmd:CI_ResponsibleParty>
									<xsl:variable name="var300_map_select_cntperp" as="xs:string?">
										<xsl:for-each select="cntinfo/cntperp/cntper">
											<xsl:sequence select="xs:string(.)"/>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var299_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:exists($var300_map_select_cntperp)">
												<xsl:for-each select="cntinfo/cntperp/cntper">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:for-each select="cntinfo/cntorgp/cntper">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var299_cond_result_exists)">
										<gmd:individualName>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space($var299_cond_result_exists)"/>
											</gco:CharacterString>
										</gmd:individualName>
									</xsl:if>
									<xsl:variable name="var309_map_select_cntperp" as="xs:string?">
										<xsl:for-each select="cntinfo/cntperp/cntorg">
											<xsl:sequence select="xs:string(.)"/>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var308_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:exists($var309_map_select_cntperp)">
												<xsl:for-each select="cntinfo/cntperp/cntorg">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:for-each select="cntinfo/cntorgp/cntorg">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var308_cond_result_exists)">
										<gmd:organisationName>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space($var308_cond_result_exists)"/>
											</gco:CharacterString>
										</gmd:organisationName>
									</xsl:if>
									<xsl:for-each select="cntinfo/cntpos">
										<gmd:positionName>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:positionName>
									</xsl:for-each>
									<gmd:contactInfo>
										<gmd:CI_Contact>
											<gmd:phone>
												<gmd:CI_Telephone>
													<xsl:for-each-group select="cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
														<xsl:variable name="var321_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:voice>
															<gco:CharacterString>
																<xsl:sequence select="$var321_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:voice>
													</xsl:for-each-group>
													<xsl:for-each-group select="cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
														<xsl:variable name="var325_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:facsimile>
															<gco:CharacterString>
																<xsl:sequence select="$var325_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:facsimile>
													</xsl:for-each-group>
												</gmd:CI_Telephone>
											</gmd:phone>
											<gmd:address>
												<xsl:for-each select="$var195_metadata/metainfo/metc/cntinfo/cntaddr">
													<gmd:CI_Address>
														<xsl:for-each-group select="$var297_ptcontac/cntinfo/cntaddr/address" group-by="fn:normalize-space(xs:string(.))">
															<xsl:variable name="var331_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
															<gmd:deliveryPoint>
																<gco:CharacterString>
																	<xsl:sequence select="$var331_cur_result_groupby"/>
																</gco:CharacterString>
															</gmd:deliveryPoint>
														</xsl:for-each-group>
														<xsl:for-each select="$var297_ptcontac/cntinfo/cntaddr">
															<gmd:city>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(city))"/>
																</gco:CharacterString>
															</gmd:city>
														</xsl:for-each>
														<xsl:for-each select="$var297_ptcontac/cntinfo/cntaddr">
															<gmd:administrativeArea>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(state))"/>
																</gco:CharacterString>
															</gmd:administrativeArea>
														</xsl:for-each>
														<xsl:for-each select="$var297_ptcontac/cntinfo/cntaddr">
															<gmd:postalCode>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(postal))"/>
																</gco:CharacterString>
															</gmd:postalCode>
														</xsl:for-each>
														<xsl:for-each select="$var297_ptcontac/cntinfo/cntaddr/country">
															<gmd:country>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																</gco:CharacterString>
															</gmd:country>
														</xsl:for-each>
														<xsl:for-each-group select="$var297_ptcontac/cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
															<xsl:variable name="var343_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
															<gmd:electronicMailAddress>
																<gco:CharacterString>
																	<xsl:sequence select="$var343_cur_result_groupby"/>
																</gco:CharacterString>
															</gmd:electronicMailAddress>
														</xsl:for-each-group>
													</gmd:CI_Address>
												</xsl:for-each>
											</gmd:address>
											<xsl:for-each select="cntinfo/hours">
												<gmd:hoursOfService>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:hoursOfService>
											</xsl:for-each>
											<xsl:for-each select="cntinfo/cntinst">
												<gmd:contactInstructions>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:contactInstructions>
											</xsl:for-each>
										</gmd:CI_Contact>
									</gmd:contactInfo>
									<gmd:role>
										<gmd:CI_RoleCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('pointOfContact'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('007'))"/>
											</xsl:attribute>
											<xsl:sequence select="'pointOfContact'"/>
										</gmd:CI_RoleCode>
									</gmd:role>
								</gmd:CI_ResponsibleParty>
							</gmd:pointOfContact>
						</xsl:for-each>
						<gmd:resourceMaintenance>
							<gmd:MD_MaintenanceInformation>
								<gmd:maintenanceAndUpdateFrequency>
									<xsl:variable name="var352_result_vmf11_inputtoresult" as="xs:string?">
										<xsl:call-template name="vmf:vmf11_inputtoresult">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(idinfo/status/update))))"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:variable name="var349_cond_result_exists" as="xs:string?" select="(if (fn:exists($var352_result_vmf11_inputtoresult)) then $var352_result_vmf11_inputtoresult else ())"/>
									<xsl:if test="fn:exists($var349_cond_result_exists)">
										<gmd:MD_MaintenanceFrequencyCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI($var349_cond_result_exists))"/>
											</xsl:attribute>
											<xsl:variable name="var351_result_vmf12_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf12_inputtoresult">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(idinfo/status/update))))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:variable name="var350_cond_result_exists" as="xs:string?" select="(if (fn:exists($var351_result_vmf12_inputtoresult)) then $var351_result_vmf12_inputtoresult else ())"/>
											<xsl:if test="fn:exists($var350_cond_result_exists)">
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI($var350_cond_result_exists))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="$var349_cond_result_exists"/>
										</gmd:MD_MaintenanceFrequencyCode>
									</xsl:if>
								</gmd:maintenanceAndUpdateFrequency>
							</gmd:MD_MaintenanceInformation>
						</gmd:resourceMaintenance>
						<xsl:for-each select="eainfo/detailed/attr/attrmfrq">
							<gmd:resourceMaintenance>
								<gmd:MD_MaintenanceInformation>
									<gmd:maintenanceAndUpdateFrequency>
										<xsl:variable name="var358_result_vmf11_inputtoresult" as="xs:string?">
											<xsl:call-template name="vmf:vmf11_inputtoresult">
												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:variable name="var355_cond_result_exists" as="xs:string?" select="(if (fn:exists($var358_result_vmf11_inputtoresult)) then $var358_result_vmf11_inputtoresult else ())"/>
										<xsl:if test="fn:exists($var355_cond_result_exists)">
											<gmd:MD_MaintenanceFrequencyCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI($var355_cond_result_exists))"/>
												</xsl:attribute>
												<xsl:variable name="var357_result_vmf12_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:vmf12_inputtoresult">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:variable name="var356_cond_result_exists" as="xs:string?" select="(if (fn:exists($var357_result_vmf12_inputtoresult)) then $var357_result_vmf12_inputtoresult else ())"/>
												<xsl:if test="fn:exists($var356_cond_result_exists)">
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI($var356_cond_result_exists))"/>
													</xsl:attribute>
												</xsl:if>
												<xsl:sequence select="$var355_cond_result_exists"/>
											</gmd:MD_MaintenanceFrequencyCode>
										</xsl:if>
									</gmd:maintenanceAndUpdateFrequency>
									<gmd:updateScope>
										<gmd:MD_ScopeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('attribute'))"/>
											</xsl:attribute>
										</gmd:MD_ScopeCode>
									</gmd:updateScope>
								</gmd:MD_MaintenanceInformation>
							</gmd:resourceMaintenance>
						</xsl:for-each>
						<xsl:for-each select="idinfo/browse">
							<gmd:graphicOverview>
								<gmd:MD_BrowseGraphic>
									<gmd:fileName>
										<xsl:for-each-group select="." group-by="xs:string(browsen)">
											<xsl:variable name="var363_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
											<gco:CharacterString>
												<xsl:sequence select="$var363_cur_result_groupby"/>
											</gco:CharacterString>
										</xsl:for-each-group>
									</gmd:fileName>
									<gmd:fileDescription>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(browsed)"/>
										</gco:CharacterString>
									</gmd:fileDescription>
									<gmd:fileType>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(xs:string(browset))"/>
										</gco:CharacterString>
									</gmd:fileType>
								</gmd:MD_BrowseGraphic>
							</gmd:graphicOverview>
						</xsl:for-each>
						<xsl:for-each-group select="idinfo/keywords/theme" group-by="(if (fn:contains(xs:string(xs:string(themekt)), 'ISO 19115')) then () else xs:string(xs:string(themekt)))">
							<xsl:variable name="var366_cur_result_groupby" as="item()+" select="current-group()"/>
							<xsl:variable name="var367_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="$var366_cur_result_groupby/themekey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('theme'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('005'))"/>
											</xsl:attribute>
											<xsl:sequence select="'theme'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<gmd:thesaurusName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var367_cur_result_groupby)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('unknown'))"/>
												</xsl:attribute>
											</gmd:date>
										</gmd:CI_Citation>
									</gmd:thesaurusName>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each-group>
						<xsl:for-each-group select="idinfo/keywords/place" group-by="xs:string(xs:string(placekt))">
							<xsl:variable name="var372_cur_result_groupby" as="item()+" select="current-group()"/>
							<xsl:variable name="var373_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="$var372_cur_result_groupby/placekey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('place'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
											</xsl:attribute>
											<xsl:sequence select="'place'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<gmd:thesaurusName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var373_cur_result_groupby)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('unknown'))"/>
												</xsl:attribute>
											</gmd:date>
										</gmd:CI_Citation>
									</gmd:thesaurusName>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each-group>
						<xsl:for-each-group select="idinfo/keywords/stratum" group-by="xs:string(xs:string(stratkt))">
							<xsl:variable name="var378_cur_result_groupby" as="item()+" select="current-group()"/>
							<xsl:variable name="var379_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="$var378_cur_result_groupby/stratkey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('stratum'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('003'))"/>
											</xsl:attribute>
											<xsl:sequence select="'stratum'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<gmd:thesaurusName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var379_cur_result_groupby)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('unknown'))"/>
												</xsl:attribute>
											</gmd:date>
										</gmd:CI_Citation>
									</gmd:thesaurusName>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each-group>
						<xsl:for-each-group select="idinfo/keywords/temporal" group-by="xs:string(xs:string(tempkt))">
							<xsl:variable name="var384_cur_result_groupby" as="item()+" select="current-group()"/>
							<xsl:variable name="var385_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="$var384_cur_result_groupby/tempkey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('temporal'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('004'))"/>
											</xsl:attribute>
											<xsl:sequence select="'temporal'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<gmd:thesaurusName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var385_cur_result_groupby)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('unknown'))"/>
												</xsl:attribute>
											</gmd:date>
										</gmd:CI_Citation>
									</gmd:thesaurusName>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each-group>
						<gmd:resourceConstraints>
							<gmd:MD_LegalConstraints>
								<gmd:accessConstraints>
									<gmd:MD_RestrictionCode>
										<xsl:attribute name="codeList">
											<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
										</xsl:attribute>
										<xsl:attribute name="codeListValue">
											<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
										</xsl:attribute>
										<xsl:attribute name="codeSpace">
											<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
										</xsl:attribute>
										<xsl:sequence select="'otherRestrictions'"/>
									</gmd:MD_RestrictionCode>
								</gmd:accessConstraints>
								<gmd:useConstraints>
									<gmd:MD_RestrictionCode>
										<xsl:attribute name="codeList">
											<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
										</xsl:attribute>
										<xsl:attribute name="codeListValue">
											<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
										</xsl:attribute>
										<xsl:attribute name="codeSpace">
											<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
										</xsl:attribute>
										<xsl:sequence select="'otherRestrictions'"/>
									</gmd:MD_RestrictionCode>
								</gmd:useConstraints>
								<gmd:otherConstraints>
									<xsl:variable name="var389_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:exists(distinfo/distliab)">
												<xsl:variable name="var394_map_select_distinfo" as="xs:string*">
													<xsl:for-each select="distinfo">
														<xsl:sequence select="xs:string(distliab)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:if test="fn:exists($var394_map_select_distinfo)">
													<xsl:sequence select="fn:string-join($var394_map_select_distinfo, ' ')"/>
												</xsl:if>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="' '"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:for-each select="$var389_cond_result_exists">
										<gco:CharacterString>
											<xsl:variable name="var392_cond_result_exists" as="xs:string" select="(if (fn:exists($var195_metadata/distinfo/distliab)) then ' Distribution Liability: ' else ' ')"/>
											<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat('Access Constraints: ', xs:string(xs:string($var195_metadata/idinfo/accconst))), ' Use Constraints: '), xs:string(xs:string($var195_metadata/idinfo/useconst))), $var392_cond_result_exists), .))"/>
										</gco:CharacterString>
									</xsl:for-each>
								</gmd:otherConstraints>
							</gmd:MD_LegalConstraints>
						</gmd:resourceConstraints>
						<xsl:for-each select="idinfo/secinfo">
							<gmd:resourceConstraints>
								<gmd:MD_SecurityConstraints>
									<gmd:classification>
										<xsl:variable name="var402_result_vmf13_inputtoresult" as="xs:string?">
											<xsl:call-template name="vmf:vmf13_inputtoresult">
												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(secclass))))"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:variable name="var399_cond_result_exists" as="xs:string?" select="(if (fn:exists($var402_result_vmf13_inputtoresult)) then $var402_result_vmf13_inputtoresult else ())"/>
										<xsl:if test="fn:exists($var399_cond_result_exists)">
											<gmd:MD_ClassificationCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI($var399_cond_result_exists))"/>
												</xsl:attribute>
												<xsl:variable name="var401_result_vmf14_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:vmf14_inputtoresult">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(secclass))))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:variable name="var400_cond_result_exists" as="xs:string?" select="(if (fn:exists($var401_result_vmf14_inputtoresult)) then $var401_result_vmf14_inputtoresult else ())"/>
												<xsl:if test="fn:exists($var400_cond_result_exists)">
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI($var400_cond_result_exists))"/>
													</xsl:attribute>
												</xsl:if>
												<xsl:sequence select="$var399_cond_result_exists"/>
											</gmd:MD_ClassificationCode>
										</xsl:if>
									</gmd:classification>
									<gmd:classificationSystem>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(secsys)"/>
										</gco:CharacterString>
									</gmd:classificationSystem>
									<gmd:handlingDescription>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(sechandl)"/>
										</gco:CharacterString>
									</gmd:handlingDescription>
								</gmd:MD_SecurityConstraints>
							</gmd:resourceConstraints>
						</xsl:for-each>
						<xsl:for-each select="idinfo/citation/citeinfo/lworkcit">
							<xsl:variable name="var403_lworkcit" as="node()" select="."/>
							<gmd:aggregationInfo>
								<gmd:MD_AggregateInformation>
									<gmd:aggregateDataSetName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(citeinfo/title)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<gmd:CI_Date>
													<gmd:date>
														<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished'))">
															<xsl:attribute name="gco:nilReason">
																<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate)))))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:variable name="var406_cond_result_logicalor" as="xs:string?">
															<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																<xsl:variable name="var411_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., '-')">
																				<xsl:if test="fn:ends-with(., '-')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var410_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values($var411_map_result_distinctvalues)">
																		<xsl:variable name="var416_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var416_cond_result_endswith)">
																			<xsl:sequence select="$var416_cond_result_endswith"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var410_map_result_distinctvalues)">
																	<xsl:sequence select="fn:string-join($var410_map_result_distinctvalues, ' ')"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var406_cond_result_logicalor">
															<gco:Date>
																<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
															</gco:Date>
														</xsl:for-each>
														<xsl:variable name="var424_cond_result_logicalor" as="xs:string?">
															<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																<xsl:variable name="var457_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., '-')">
																				<xsl:if test="fn:ends-with(., '-')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var456_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values($var457_map_result_distinctvalues)">
																		<xsl:variable name="var462_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var462_cond_result_endswith)">
																			<xsl:sequence select="$var462_cond_result_endswith"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var456_map_result_distinctvalues)">
																	<xsl:sequence select="fn:string-join($var456_map_result_distinctvalues, ' ')"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var424_cond_result_logicalor">
															<xsl:variable name="var425_cur_cond_result_logicalor" as="xs:string" select="."/>
															<xsl:variable name="var427_map_select_pubtime" as="xs:string?">
																<xsl:for-each select="$var403_lworkcit/citeinfo/pubtime">
																	<xsl:variable name="var454_result_vmf6_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf6_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var453_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var454_result_vmf6_inputtoresult)) then (if (fn:contains($var454_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																	<xsl:if test="not(fn:exists($var453_cond_result_exists))">
																		<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:for-each select="fn:distinct-values($var427_map_select_pubtime)">
																<xsl:variable name="var432_cond_result_endswith" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., ':')">
																			<xsl:if test="fn:ends-with(., ':')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var432_cond_result_endswith)">
																	<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var432_cond_result_endswith))), 'un'))">
																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var432_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var432_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var432_cond_result_endswith)))))) then 'T' else ()))">
																			<gco:DateTime>
																				<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var425_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var432_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var432_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var432_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var432_cond_result_endswith)))))))"/>
																			</gco:DateTime>
																		</xsl:if>
																	</xsl:if>
																</xsl:if>
															</xsl:for-each>
														</xsl:for-each>
													</gmd:date>
													<gmd:dateType>
														<gmd:CI_DateTypeCode>
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
															</xsl:attribute>
															<xsl:attribute name="codeListValue">
																<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
															</xsl:attribute>
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
															</xsl:attribute>
															<xsl:sequence select="'publication'"/>
														</gmd:CI_DateTypeCode>
													</gmd:dateType>
												</gmd:CI_Date>
											</gmd:date>
											<gmd:edition>
												<xsl:for-each select="citeinfo/edition">
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:edition>
											<xsl:for-each-group select="citeinfo/origin" group-by="fn:normalize-space(xs:string(xs:string(.)))">
												<xsl:variable name="var473_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:citedResponsibleParty>
													<gmd:CI_ResponsibleParty>
														<gmd:organisationName>
															<gco:CharacterString>
																<xsl:sequence select="$var473_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:organisationName>
														<gmd:role>
															<gmd:CI_RoleCode>
																<xsl:attribute name="codeList">
																	<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI('resourceProvider'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI('001'))"/>
																</xsl:attribute>
																<xsl:sequence select="'resourceProvider'"/>
															</gmd:CI_RoleCode>
														</gmd:role>
													</gmd:CI_ResponsibleParty>
												</gmd:citedResponsibleParty>
											</xsl:for-each-group>
											<xsl:for-each select="citeinfo/geoform">
												<gmd:presentationForm>
													<xsl:variable name="var480_result_vmf7_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf7_inputtoresult">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:variable name="var477_cond_result_exists" as="xs:string?" select="(if (fn:exists($var480_result_vmf7_inputtoresult)) then $var480_result_vmf7_inputtoresult else ())"/>
													<xsl:if test="fn:exists($var477_cond_result_exists)">
														<gmd:CI_PresentationFormCode>
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
															</xsl:attribute>
															<xsl:attribute name="codeListValue">
																<xsl:sequence select="xs:string(xs:anyURI($var477_cond_result_exists))"/>
															</xsl:attribute>
															<xsl:variable name="var479_result_vmf8_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf8_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:variable name="var478_cond_result_exists" as="xs:string?" select="(if (fn:exists($var479_result_vmf8_inputtoresult)) then $var479_result_vmf8_inputtoresult else ())"/>
															<xsl:if test="fn:exists($var478_cond_result_exists)">
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI($var478_cond_result_exists))"/>
																</xsl:attribute>
															</xsl:if>
															<xsl:sequence select="$var477_cond_result_exists"/>
														</gmd:CI_PresentationFormCode>
													</xsl:if>
												</gmd:presentationForm>
											</xsl:for-each>
											<xsl:for-each select="citeinfo/serinfo">
												<gmd:series>
													<gmd:CI_Series>
														<gmd:name>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(sername)"/>
															</gco:CharacterString>
														</gmd:name>
														<gmd:issueIdentification>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(issue)"/>
															</gco:CharacterString>
														</gmd:issueIdentification>
													</gmd:CI_Series>
												</gmd:series>
											</xsl:for-each>
											<gmd:otherCitationDetails>
												<xsl:for-each select="citeinfo/othercit">
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:otherCitationDetails>
										</gmd:CI_Citation>
									</gmd:aggregateDataSetName>
									<gmd:associationType>
										<gmd:DS_AssociationTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('largerWorkCitation'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
											</xsl:attribute>
											<xsl:sequence select="'largerWorkCitation'"/>
										</gmd:DS_AssociationTypeCode>
									</gmd:associationType>
								</gmd:MD_AggregateInformation>
							</gmd:aggregationInfo>
						</xsl:for-each>
						<xsl:for-each select="idinfo/crossref">
							<xsl:variable name="var485_crossref" as="node()" select="."/>
							<gmd:aggregationInfo>
								<gmd:MD_AggregateInformation>
									<gmd:aggregateDataSetName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(citeinfo/title)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<gmd:CI_Date>
													<gmd:date>
														<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished'))">
															<xsl:attribute name="gco:nilReason">
																<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate)))))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:variable name="var488_cond_result_logicalor" as="xs:string?">
															<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																<xsl:variable name="var493_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., '-')">
																				<xsl:if test="fn:ends-with(., '-')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var492_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values($var493_map_result_distinctvalues)">
																		<xsl:variable name="var498_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var498_cond_result_endswith)">
																			<xsl:sequence select="$var498_cond_result_endswith"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var492_map_result_distinctvalues)">
																	<xsl:sequence select="fn:string-join($var492_map_result_distinctvalues, ' ')"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var488_cond_result_logicalor">
															<gco:Date>
																<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
															</gco:Date>
														</xsl:for-each>
														<xsl:variable name="var506_cond_result_logicalor" as="xs:string?">
															<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																<xsl:variable name="var539_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., '-')">
																				<xsl:if test="fn:ends-with(., '-')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var538_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values($var539_map_result_distinctvalues)">
																		<xsl:variable name="var544_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var544_cond_result_endswith)">
																			<xsl:sequence select="$var544_cond_result_endswith"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var538_map_result_distinctvalues)">
																	<xsl:sequence select="fn:string-join($var538_map_result_distinctvalues, ' ')"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var506_cond_result_logicalor">
															<xsl:variable name="var507_cur_cond_result_logicalor" as="xs:string" select="."/>
															<xsl:variable name="var509_map_select_pubtime" as="xs:string?">
																<xsl:for-each select="$var485_crossref/citeinfo/pubtime">
																	<xsl:variable name="var536_result_vmf6_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf6_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var535_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var536_result_vmf6_inputtoresult)) then (if (fn:contains($var536_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																	<xsl:if test="not(fn:exists($var535_cond_result_exists))">
																		<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:for-each select="fn:distinct-values($var509_map_select_pubtime)">
																<xsl:variable name="var514_cond_result_endswith" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., ':')">
																			<xsl:if test="fn:ends-with(., ':')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var514_cond_result_endswith)">
																	<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var514_cond_result_endswith))), 'un'))">
																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var514_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var514_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var514_cond_result_endswith)))))) then 'T' else ()))">
																			<gco:DateTime>
																				<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var507_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var514_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var514_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var514_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var514_cond_result_endswith)))))))"/>
																			</gco:DateTime>
																		</xsl:if>
																	</xsl:if>
																</xsl:if>
															</xsl:for-each>
														</xsl:for-each>
													</gmd:date>
													<gmd:dateType>
														<gmd:CI_DateTypeCode>
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
															</xsl:attribute>
															<xsl:attribute name="codeListValue">
																<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
															</xsl:attribute>
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
															</xsl:attribute>
															<xsl:sequence select="'publication'"/>
														</gmd:CI_DateTypeCode>
													</gmd:dateType>
												</gmd:CI_Date>
											</gmd:date>
											<xsl:for-each select="citeinfo/edition">
												<gmd:edition>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:edition>
											</xsl:for-each>
											<xsl:for-each-group select="citeinfo/origin" group-by="fn:normalize-space(xs:string(xs:string(.)))">
												<xsl:variable name="var555_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:citedResponsibleParty>
													<gmd:CI_ResponsibleParty>
														<gmd:organisationName>
															<gco:CharacterString>
																<xsl:sequence select="$var555_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:organisationName>
														<gmd:role>
															<gmd:CI_RoleCode>
																<xsl:attribute name="codeList">
																	<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI('originator'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
																</xsl:attribute>
																<xsl:sequence select="'originator'"/>
															</gmd:CI_RoleCode>
														</gmd:role>
													</gmd:CI_ResponsibleParty>
												</gmd:citedResponsibleParty>
											</xsl:for-each-group>
											<xsl:for-each select="citeinfo/pubinfo">
												<gmd:citedResponsibleParty>
													<gmd:CI_ResponsibleParty>
														<gmd:organisationName>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(publish)"/>
															</gco:CharacterString>
														</gmd:organisationName>
														<gmd:contactInfo>
															<gmd:CI_Contact>
																<gmd:address>
																	<gmd:CI_Address>
																		<gmd:city>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:substring-before(xs:string(pubplace), ',')"/>
																			</gco:CharacterString>
																		</gmd:city>
																		<gmd:administrativeArea>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:substring-after(xs:string(pubplace), ',')"/>
																			</gco:CharacterString>
																		</gmd:administrativeArea>
																	</gmd:CI_Address>
																</gmd:address>
																<xsl:for-each select="$var485_crossref/citeinfo/onlink">
																	<gmd:onlineResource>
																		<gmd:CI_OnlineResource>
																			<gmd:linkage>
																				<gmd:URL>
																					<xsl:sequence select="xs:string(xs:anyURI(xs:string(.)))"/>
																				</gmd:URL>
																			</gmd:linkage>
																		</gmd:CI_OnlineResource>
																	</gmd:onlineResource>
																</xsl:for-each>
															</gmd:CI_Contact>
														</gmd:contactInfo>
														<gmd:role>
															<gmd:CI_RoleCode>
																<xsl:attribute name="codeList">
																	<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI('publisher'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI('010'))"/>
																</xsl:attribute>
																<xsl:sequence select="'publisher'"/>
															</gmd:CI_RoleCode>
														</gmd:role>
													</gmd:CI_ResponsibleParty>
												</gmd:citedResponsibleParty>
											</xsl:for-each>
											<xsl:for-each select="citeinfo/geoform">
												<gmd:presentationForm>
													<xsl:variable name="var566_result_vmf7_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf7_inputtoresult">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:variable name="var563_cond_result_exists" as="xs:string?" select="(if (fn:exists($var566_result_vmf7_inputtoresult)) then $var566_result_vmf7_inputtoresult else ())"/>
													<xsl:if test="fn:exists($var563_cond_result_exists)">
														<gmd:CI_PresentationFormCode>
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
															</xsl:attribute>
															<xsl:attribute name="codeListValue">
																<xsl:sequence select="xs:string(xs:anyURI($var563_cond_result_exists))"/>
															</xsl:attribute>
															<xsl:variable name="var565_result_vmf8_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf8_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:variable name="var564_cond_result_exists" as="xs:string?" select="(if (fn:exists($var565_result_vmf8_inputtoresult)) then $var565_result_vmf8_inputtoresult else ())"/>
															<xsl:if test="fn:exists($var564_cond_result_exists)">
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI($var564_cond_result_exists))"/>
																</xsl:attribute>
															</xsl:if>
															<xsl:sequence select="$var563_cond_result_exists"/>
														</gmd:CI_PresentationFormCode>
													</xsl:if>
												</gmd:presentationForm>
											</xsl:for-each>
											<xsl:for-each select="citeinfo/serinfo">
												<gmd:series>
													<gmd:CI_Series>
														<gmd:name>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(sername)"/>
															</gco:CharacterString>
														</gmd:name>
														<gmd:issueIdentification>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(issue)"/>
															</gco:CharacterString>
														</gmd:issueIdentification>
													</gmd:CI_Series>
												</gmd:series>
											</xsl:for-each>
											<gmd:otherCitationDetails>
												<xsl:for-each select="citeinfo/othercit">
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:otherCitationDetails>
										</gmd:CI_Citation>
									</gmd:aggregateDataSetName>
									<gmd:associationType>
										<gmd:DS_AssociationTypeCode>
											<xsl:variable name="var572_cond_result_exists" as="xs:string?" select="(if (fn:exists($var195_metadata/idinfo/citation/citeinfo/lworkcit/citeinfo/origin)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode' else ())"/>
											<xsl:variable name="var571_cond_result_exists" as="xs:string?" select="(if (fn:exists($var572_cond_result_exists)) then $var572_cond_result_exists else ())"/>
											<xsl:if test="fn:exists($var571_cond_result_exists)">
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI($var571_cond_result_exists))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('crossReference'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('001'))"/>
											</xsl:attribute>
											<xsl:sequence select="'crossReference'"/>
										</gmd:DS_AssociationTypeCode>
									</gmd:associationType>
								</gmd:MD_AggregateInformation>
							</gmd:aggregationInfo>
						</xsl:for-each>
						<xsl:for-each select="spdoinfo">
							<gmd:spatialRepresentationType>
								<xsl:for-each select="direct">
									<xsl:variable name="var577_result_vmf15_inputtoresult" as="xs:string?">
										<xsl:call-template name="vmf:vmf15_inputtoresult">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:if test="fn:exists($var577_result_vmf15_inputtoresult)">
										<gmd:MD_SpatialRepresentationTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_SpatialRepresentationTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI($var577_result_vmf15_inputtoresult))"/>
											</xsl:attribute>
											<xsl:variable name="var578_result_vmf16_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf16_inputtoresult">
													<xsl:with-param name="input" select="$var577_result_vmf15_inputtoresult"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:if test="fn:exists($var578_result_vmf16_inputtoresult)">
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI($var578_result_vmf16_inputtoresult))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="$var577_result_vmf15_inputtoresult"/>
										</gmd:MD_SpatialRepresentationTypeCode>
									</xsl:if>
								</xsl:for-each>
							</gmd:spatialRepresentationType>
						</xsl:for-each>
						<gmd:language>
							<gco:CharacterString>
								<xsl:sequence select="'eng; USA'"/>
							</gco:CharacterString>
						</gmd:language>
						<xsl:for-each select="idinfo/keywords/theme">
							<xsl:variable name="var579_theme" as="node()" select="."/>
							<xsl:for-each select="themekey">
								<xsl:variable name="var584_cond_result_contains" as="xs:boolean?">
									<xsl:if test="fn:contains(xs:string(xs:string($var579_theme/themekt)), 'ISO 19115')">
										<xsl:if test="fn:exists((if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ()))">
											<xsl:if test="not(fn:contains(fn:normalize-space((if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ())), '0'))">
												<xsl:if test="(((('0' != (if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ())) and ('false' != (if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ()))) and fn:boolean((if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ()))) and ((('0' != fn:normalize-space((if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ()))) and ('false' != fn:normalize-space((if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ())))) and fn:boolean(fn:normalize-space((if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ())))))">
													<xsl:sequence select="fn:true()"/>
												</xsl:if>
											</xsl:if>
										</xsl:if>
									</xsl:if>
								</xsl:variable>
								<xsl:if test="fn:exists($var584_cond_result_contains)">
									<gmd:topicCategory>
										<xsl:if test="fn:contains(xs:string(xs:string($var579_theme/themekt)), 'ISO 19115')">
											<xsl:if test="fn:exists((if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ()))">
												<xsl:if test="not(fn:contains(fn:normalize-space((if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ())), '0'))">
													<xsl:variable name="var585_result_vmf17_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf17_inputtoresult">
															<xsl:with-param name="input" select="fn:lower-case(fn:normalize-space((if (((('0' != xs:string($var579_theme/themekt)) and ('false' != xs:string($var579_theme/themekt))) and fn:boolean(xs:string($var579_theme/themekt)))) then xs:string(.) else ())))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var585_result_vmf17_inputtoresult)">
														<gmd:MD_TopicCategoryCode>
															<xsl:sequence select="$var585_result_vmf17_inputtoresult"/>
														</gmd:MD_TopicCategoryCode>
													</xsl:if>
												</xsl:if>
											</xsl:if>
										</xsl:if>
									</gmd:topicCategory>
								</xsl:if>
							</xsl:for-each>
						</xsl:for-each>
						<xsl:for-each select="idinfo/native">
							<xsl:variable name="var587_native" as="node()" select="."/>
							<gmd:environmentDescription>
								<xsl:variable name="var589_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="fn:exists($var195_metadata/distinfo/techpreq)">
											<xsl:variable name="var594_map_select_distinfo" as="xs:string*">
												<xsl:for-each select="$var195_metadata/distinfo/techpreq">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var594_map_select_distinfo)">
												<xsl:sequence select="fn:string-join($var594_map_select_distinfo, ' ')"/>
											</xsl:if>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="' '"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:for-each select="$var589_cond_result_exists">
									<gco:CharacterString>
										<xsl:variable name="var592_cond_result_exists" as="xs:string" select="(if (fn:exists($var195_metadata/distinfo/techpreq)) then ' Technical Prerequisites: ' else ' ')"/>
										<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat('Native Dataset Environment: ', xs:string($var587_native)), $var592_cond_result_exists), .)))"/>
									</gco:CharacterString>
								</xsl:for-each>
							</gmd:environmentDescription>
						</xsl:for-each>
						<gmd:extent>
							<gmd:EX_Extent>
								<xsl:attribute name="id">
									<xsl:sequence select="xs:string(xs:ID('boundingExtent'))"/>
								</xsl:attribute>
								<gmd:geographicElement>
									<xsl:for-each select="idinfo/spdom/dsgpoly">
										<xsl:variable name="var597_dsgpoly" as="node()" select="."/>
										<gmd:EX_BoundingPolygon>
											<gmd:polygon>
												<gml:Polygon>
													<xsl:attribute name="gml:id">
														<xsl:sequence select="xs:string(xs:ID('boundingPolygon'))"/>
													</xsl:attribute>
													<gml:interior>
														<gml:LinearRing>
															<gml:coordinates>
																<xsl:variable name="var602_map_select_grngpoin" as="xs:string*">
																	<xsl:for-each select="dsgpolyo/grngpoin">
																		<xsl:sequence select="fn:concat(fn:concat(fn:concat(xs:string(xs:double(gringlat)), ', '), xs:string(xs:double(gringlon))), '; ')"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var599_cond_result_exists" as="xs:string*">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var602_map_select_grngpoin)">
																			<xsl:for-each select="dsgpolyo/grngpoin">
																				<xsl:sequence select="fn:concat(fn:concat(fn:concat(xs:string(xs:double(gringlat)), ', '), xs:string(xs:double(gringlon))), '; ')"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="dsgpolyo/gring">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:for-each select="$var599_cond_result_exists">
																	<xsl:attribute name="decimal">
																		<xsl:sequence select="fn:normalize-space(.)"/>
																	</xsl:attribute>
																</xsl:for-each>
															</gml:coordinates>
														</gml:LinearRing>
													</gml:interior>
												</gml:Polygon>
											</gmd:polygon>
										</gmd:EX_BoundingPolygon>
									</xsl:for-each>
									<gmd:EX_GeographicBoundingBox>
										<xsl:attribute name="id">
											<xsl:sequence select="xs:string(xs:ID('boundingGeographicBoundingBox'))"/>
										</xsl:attribute>
										<gmd:westBoundLongitude>
											<gco:Decimal>
												<xsl:sequence select="xs:string(xs:decimal(idinfo/spdom/bounding/westbc))"/>
											</gco:Decimal>
										</gmd:westBoundLongitude>
										<gmd:eastBoundLongitude>
											<gco:Decimal>
												<xsl:sequence select="xs:string(xs:decimal(idinfo/spdom/bounding/eastbc))"/>
											</gco:Decimal>
										</gmd:eastBoundLongitude>
										<gmd:southBoundLatitude>
											<gco:Decimal>
												<xsl:sequence select="xs:string(xs:decimal(idinfo/spdom/bounding/southbc))"/>
											</gco:Decimal>
										</gmd:southBoundLatitude>
										<gmd:northBoundLatitude>
											<gco:Decimal>
												<xsl:sequence select="xs:string(xs:decimal(idinfo/spdom/bounding/northbc))"/>
											</gco:Decimal>
										</gmd:northBoundLatitude>
									</gmd:EX_GeographicBoundingBox>
								</gmd:geographicElement>
								<xsl:for-each select="idinfo/timeperd/timeinfo/sngdate">
									<xsl:variable name="var610_sngdate" as="node()" select="."/>
									<gmd:temporalElement>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
											</xsl:attribute>
											<gmd:extent>
												<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
													<xsl:attribute name="gco:nilReason">
														<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/>
													</xsl:attribute>
												</xsl:if>
												<gml:TimeInstant>
													<xsl:attribute name="gml:id">
														<xsl:sequence select="xs:string(xs:ID('boundingTimeInstantExtent'))"/>
													</xsl:attribute>
													<gml:description>
														<xsl:sequence select="xs:string(xs:string($var195_metadata/idinfo/timeperd/current))"/>
													</gml:description>
													<xsl:variable name="var683_cond_result_logicalor" as="xs:string?">
														<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
															<xsl:variable name="var716_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., '-')">
																			<xsl:if test="fn:ends-with(., '-')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var715_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values($var716_map_result_distinctvalues)">
																	<xsl:variable name="var721_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																				<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																						<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var721_cond_result_endswith)">
																		<xsl:sequence select="$var721_cond_result_endswith"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var715_map_result_distinctvalues)">
																<xsl:sequence select="fn:string-join($var715_map_result_distinctvalues, ' ')"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:variable name="var616_map_cond_result_logicalor" as="xs:string*">
														<xsl:for-each select="$var683_cond_result_logicalor">
															<xsl:variable name="var684_cur_cond_result_logicalor" as="xs:string" select="."/>
															<xsl:variable name="var686_map_select_time" as="xs:string?">
																<xsl:for-each select="$var610_sngdate/time">
																	<xsl:variable name="var713_result_vmf6_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf6_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var712_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var713_result_vmf6_inputtoresult)) then (if (fn:contains($var713_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																	<xsl:if test="not(fn:exists($var712_cond_result_exists))">
																		<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:for-each select="fn:distinct-values($var686_map_select_time)">
																<xsl:variable name="var691_cond_result_endswith" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., ':')">
																			<xsl:if test="fn:ends-with(., ':')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var691_cond_result_endswith)">
																	<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var691_cond_result_endswith))), 'un'))">
																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var691_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var691_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var691_cond_result_endswith)))))) then 'T' else ()))">
																			<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var684_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var691_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var691_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var691_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var691_cond_result_endswith)))))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:if>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var615_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var616_map_cond_result_logicalor)">
																<xsl:variable name="var619_cond_result_logicalor" as="xs:string?">
																	<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																		<xsl:variable name="var652_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., '-')">
																						<xsl:if test="fn:ends-with(., '-')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var651_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var652_map_result_distinctvalues)">
																				<xsl:variable name="var657_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var657_cond_result_endswith)">
																					<xsl:sequence select="$var657_cond_result_endswith"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var651_map_result_distinctvalues)">
																			<xsl:sequence select="fn:string-join($var651_map_result_distinctvalues, ' ')"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var619_cond_result_logicalor">
																	<xsl:variable name="var620_cur_cond_result_logicalor" as="xs:string" select="."/>
																	<xsl:variable name="var622_map_select_time" as="xs:string?">
																		<xsl:for-each select="$var610_sngdate/time">
																			<xsl:variable name="var649_result_vmf6_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf6_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:variable name="var648_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var649_result_vmf6_inputtoresult)) then (if (fn:contains($var649_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																			<xsl:if test="not(fn:exists($var648_cond_result_exists))">
																				<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:for-each select="fn:distinct-values($var622_map_select_time)">
																		<xsl:variable name="var627_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., ':')">
																					<xsl:if test="fn:ends-with(., ':')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var627_cond_result_endswith)">
																			<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var627_cond_result_endswith))), 'un'))">
																				<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var627_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var627_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var627_cond_result_endswith)))))) then 'T' else ()))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var620_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var627_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var627_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var627_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var627_cond_result_endswith)))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:variable name="var665_cond_result_logicalor" as="xs:string?">
																	<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																		<xsl:variable name="var670_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., '-')">
																						<xsl:if test="fn:ends-with(., '-')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var669_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var670_map_result_distinctvalues)">
																				<xsl:variable name="var675_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var675_cond_result_endswith)">
																					<xsl:sequence select="$var675_cond_result_endswith"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var669_map_result_distinctvalues)">
																			<xsl:sequence select="fn:string-join($var669_map_result_distinctvalues, ' ')"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var665_cond_result_logicalor">
																	<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="var612_cond_result_exists" as="xs:string*" select="(if (fn:exists($var615_cond_result_exists)) then $var615_cond_result_exists else xs:string((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')) then fn:current-dateTime() else '')))"/>
													<xsl:for-each select="$var612_cond_result_exists">
														<gml:timePosition>
															<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var610_sngdate/caldate))), 'present')) then 'now' else ()))">
																<xsl:attribute name="indeterminatePosition">
																	<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var610_sngdate/caldate))), 'present')) then 'now' else ())"/>
																</xsl:attribute>
															</xsl:if>
															<xsl:sequence select="xs:string(xs:string(.))"/>
														</gml:timePosition>
													</xsl:for-each>
												</gml:TimeInstant>
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
								<xsl:for-each select="idinfo/timeperd/timeinfo/mdattim/sngdate">
									<xsl:variable name="var728_sngdate" as="node()" select="."/>
									<gmd:temporalElement>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
											</xsl:attribute>
											<gmd:extent>
												<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
													<xsl:attribute name="gco:nilReason">
														<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/>
													</xsl:attribute>
												</xsl:if>
												<gml:TimeInstant>
													<xsl:attribute name="gml:id">
														<xsl:sequence select="xs:string(xs:ID('boundingTimeInstantExtent'))"/>
													</xsl:attribute>
													<gml:description>
														<xsl:sequence select="xs:string(xs:string($var195_metadata/idinfo/timeperd/current))"/>
													</gml:description>
													<xsl:variable name="var802_cond_result_logicalor" as="xs:string?">
														<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
															<xsl:variable name="var835_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., '-')">
																			<xsl:if test="fn:ends-with(., '-')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var834_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values($var835_map_result_distinctvalues)">
																	<xsl:variable name="var840_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																				<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																						<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var840_cond_result_endswith)">
																		<xsl:sequence select="$var840_cond_result_endswith"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var834_map_result_distinctvalues)">
																<xsl:sequence select="fn:string-join($var834_map_result_distinctvalues, ' ')"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:variable name="var735_map_cond_result_logicalor" as="xs:string*">
														<xsl:for-each select="$var802_cond_result_logicalor">
															<xsl:variable name="var803_cur_cond_result_logicalor" as="xs:string" select="."/>
															<xsl:variable name="var805_map_select_time" as="xs:string?">
																<xsl:for-each select="$var728_sngdate/time">
																	<xsl:variable name="var832_result_vmf6_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf6_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var831_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var832_result_vmf6_inputtoresult)) then (if (fn:contains($var832_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																	<xsl:if test="not(fn:exists($var831_cond_result_exists))">
																		<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:for-each select="fn:distinct-values($var805_map_select_time)">
																<xsl:variable name="var810_cond_result_endswith" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., ':')">
																			<xsl:if test="fn:ends-with(., ':')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var810_cond_result_endswith)">
																	<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var810_cond_result_endswith))), 'un'))">
																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var810_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var810_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var810_cond_result_endswith)))))) then 'T' else ()))">
																			<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var803_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var810_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var810_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var810_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var810_cond_result_endswith)))))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:if>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var734_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var735_map_cond_result_logicalor)">
																<xsl:variable name="var738_cond_result_logicalor" as="xs:string?">
																	<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																		<xsl:variable name="var771_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., '-')">
																						<xsl:if test="fn:ends-with(., '-')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var770_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var771_map_result_distinctvalues)">
																				<xsl:variable name="var776_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var776_cond_result_endswith)">
																					<xsl:sequence select="$var776_cond_result_endswith"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var770_map_result_distinctvalues)">
																			<xsl:sequence select="fn:string-join($var770_map_result_distinctvalues, ' ')"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var738_cond_result_logicalor">
																	<xsl:variable name="var739_cur_cond_result_logicalor" as="xs:string" select="."/>
																	<xsl:variable name="var741_map_select_time" as="xs:string?">
																		<xsl:for-each select="$var728_sngdate/time">
																			<xsl:variable name="var768_result_vmf6_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf6_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:variable name="var767_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var768_result_vmf6_inputtoresult)) then (if (fn:contains($var768_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																			<xsl:if test="not(fn:exists($var767_cond_result_exists))">
																				<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:for-each select="fn:distinct-values($var741_map_select_time)">
																		<xsl:variable name="var746_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., ':')">
																					<xsl:if test="fn:ends-with(., ':')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var746_cond_result_endswith)">
																			<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var746_cond_result_endswith))), 'un'))">
																				<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var746_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var746_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var746_cond_result_endswith)))))) then 'T' else ()))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var739_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var746_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var746_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var746_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var746_cond_result_endswith)))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:variable name="var784_cond_result_logicalor" as="xs:string?">
																	<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																		<xsl:variable name="var789_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., '-')">
																						<xsl:if test="fn:ends-with(., '-')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var788_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var789_map_result_distinctvalues)">
																				<xsl:variable name="var794_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var794_cond_result_endswith)">
																					<xsl:sequence select="$var794_cond_result_endswith"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var788_map_result_distinctvalues)">
																			<xsl:sequence select="fn:string-join($var788_map_result_distinctvalues, ' ')"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var784_cond_result_logicalor">
																	<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="var730_cond_result_exists" as="xs:string*" select="(if (fn:exists($var734_cond_result_exists)) then $var734_cond_result_exists else xs:string((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')) then fn:current-dateTime() else '')))"/>
													<xsl:for-each select="$var730_cond_result_exists">
														<gml:timePosition>
															<xsl:variable name="var733_cond_result_exists" as="xs:string?" select="(if (fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var728_sngdate/caldate))), 'present')) then 'now' else ()))) then (if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var728_sngdate/caldate))), 'present')) then 'now' else ()) else 'unknown')"/>
															<xsl:if test="fn:exists($var733_cond_result_exists)">
																<xsl:attribute name="indeterminatePosition">
																	<xsl:sequence select="$var733_cond_result_exists"/>
																</xsl:attribute>
															</xsl:if>
															<xsl:sequence select="xs:string(xs:string(.))"/>
														</gml:timePosition>
													</xsl:for-each>
												</gml:TimeInstant>
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
								<xsl:for-each select="idinfo/timeperd/timeinfo/rngdates">
									<xsl:variable name="var847_rngdates" as="node()" select="."/>
									<gmd:temporalElement>
										<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished'))">
											<xsl:attribute name="gco:nilReason">
												<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(begdate)))))"/>
											</xsl:attribute>
										</xsl:if>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
											</xsl:attribute>
											<gmd:extent>
												<gml:TimePeriod>
													<xsl:attribute name="gml:id">
														<xsl:sequence select="xs:string(xs:ID('boundingTimePeriodExtent'))"/>
													</xsl:attribute>
													<gml:description>
														<xsl:sequence select="xs:string(xs:string($var195_metadata/idinfo/timeperd/current))"/>
													</gml:description>
													<xsl:variable name="var920_cond_result_logicalor" as="xs:string?">
														<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present')))">
															<xsl:variable name="var953_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., '-')">
																			<xsl:if test="fn:ends-with(., '-')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var952_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values($var953_map_result_distinctvalues)">
																	<xsl:variable name="var958_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																				<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																						<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var958_cond_result_endswith)">
																		<xsl:sequence select="$var958_cond_result_endswith"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var952_map_result_distinctvalues)">
																<xsl:sequence select="fn:string-join($var952_map_result_distinctvalues, ' ')"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:variable name="var853_map_cond_result_logicalor" as="xs:string*">
														<xsl:for-each select="$var920_cond_result_logicalor">
															<xsl:variable name="var921_cur_cond_result_logicalor" as="xs:string" select="."/>
															<xsl:variable name="var923_map_select_begtime" as="xs:string?">
																<xsl:for-each select="$var847_rngdates/begtime">
																	<xsl:variable name="var950_result_vmf6_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf6_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var949_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var950_result_vmf6_inputtoresult)) then (if (fn:contains($var950_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																	<xsl:if test="not(fn:exists($var949_cond_result_exists))">
																		<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:for-each select="fn:distinct-values($var923_map_select_begtime)">
																<xsl:variable name="var928_cond_result_endswith" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., ':')">
																			<xsl:if test="fn:ends-with(., ':')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var928_cond_result_endswith)">
																	<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var928_cond_result_endswith))), 'un'))">
																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var928_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var928_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var928_cond_result_endswith)))))) then 'T' else ()))">
																			<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var921_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var928_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var928_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var928_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var928_cond_result_endswith)))))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:if>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var852_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var853_map_cond_result_logicalor)">
																<xsl:variable name="var856_cond_result_logicalor" as="xs:string?">
																	<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present')))">
																		<xsl:variable name="var889_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., '-')">
																						<xsl:if test="fn:ends-with(., '-')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var888_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var889_map_result_distinctvalues)">
																				<xsl:variable name="var894_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var894_cond_result_endswith)">
																					<xsl:sequence select="$var894_cond_result_endswith"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var888_map_result_distinctvalues)">
																			<xsl:sequence select="fn:string-join($var888_map_result_distinctvalues, ' ')"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var856_cond_result_logicalor">
																	<xsl:variable name="var857_cur_cond_result_logicalor" as="xs:string" select="."/>
																	<xsl:variable name="var859_map_select_begtime" as="xs:string?">
																		<xsl:for-each select="$var847_rngdates/begtime">
																			<xsl:variable name="var886_result_vmf6_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf6_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:variable name="var885_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var886_result_vmf6_inputtoresult)) then (if (fn:contains($var886_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																			<xsl:if test="not(fn:exists($var885_cond_result_exists))">
																				<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:for-each select="fn:distinct-values($var859_map_select_begtime)">
																		<xsl:variable name="var864_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., ':')">
																					<xsl:if test="fn:ends-with(., ':')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var864_cond_result_endswith)">
																			<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var864_cond_result_endswith))), 'un'))">
																				<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var864_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var864_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var864_cond_result_endswith)))))) then 'T' else ()))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var857_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var864_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var864_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var864_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var864_cond_result_endswith)))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:variable name="var902_cond_result_logicalor" as="xs:string?">
																	<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present')))">
																		<xsl:variable name="var907_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., '-')">
																						<xsl:if test="fn:ends-with(., '-')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var906_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var907_map_result_distinctvalues)">
																				<xsl:variable name="var912_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var912_cond_result_endswith)">
																					<xsl:sequence select="$var912_cond_result_endswith"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var906_map_result_distinctvalues)">
																			<xsl:sequence select="fn:string-join($var906_map_result_distinctvalues, ' ')"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var902_cond_result_logicalor">
																	<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="var849_cond_result_exists" as="xs:string*" select="(if (fn:exists($var852_cond_result_exists)) then $var852_cond_result_exists else xs:string((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present')) then fn:current-dateTime() else '')))"/>
													<xsl:for-each select="$var849_cond_result_exists">
														<gml:beginPosition>
															<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var847_rngdates/begdate))), 'present')) then 'now' else ()))">
																<xsl:attribute name="indeterminatePosition">
																	<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var847_rngdates/begdate))), 'present')) then 'now' else ())"/>
																</xsl:attribute>
															</xsl:if>
															<xsl:sequence select="xs:string(xs:string(.))"/>
														</gml:beginPosition>
													</xsl:for-each>
													<xsl:variable name="var1036_cond_result_logicalor" as="xs:string?">
														<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present')))">
															<xsl:variable name="var1069_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., '-')">
																			<xsl:if test="fn:ends-with(., '-')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var1068_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values($var1069_map_result_distinctvalues)">
																	<xsl:variable name="var1074_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																				<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																						<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1074_cond_result_endswith)">
																		<xsl:sequence select="$var1074_cond_result_endswith"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var1068_map_result_distinctvalues)">
																<xsl:sequence select="fn:string-join($var1068_map_result_distinctvalues, ' ')"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:variable name="var969_map_cond_result_logicalor" as="xs:string*">
														<xsl:for-each select="$var1036_cond_result_logicalor">
															<xsl:variable name="var1037_cur_cond_result_logicalor" as="xs:string" select="."/>
															<xsl:variable name="var1039_map_select_endtime" as="xs:string?">
																<xsl:for-each select="$var847_rngdates/endtime">
																	<xsl:variable name="var1066_result_vmf6_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf6_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var1065_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1066_result_vmf6_inputtoresult)) then (if (fn:contains($var1066_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																	<xsl:if test="not(fn:exists($var1065_cond_result_exists))">
																		<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:for-each select="fn:distinct-values($var1039_map_select_endtime)">
																<xsl:variable name="var1044_cond_result_endswith" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., ':')">
																			<xsl:if test="fn:ends-with(., ':')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var1044_cond_result_endswith)">
																	<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1044_cond_result_endswith))), 'un'))">
																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1044_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1044_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1044_cond_result_endswith)))))) then 'T' else ()))">
																			<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1037_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1044_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1044_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1044_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var1044_cond_result_endswith)))))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:if>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var968_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var969_map_cond_result_logicalor)">
																<xsl:variable name="var972_cond_result_logicalor" as="xs:string?">
																	<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present')))">
																		<xsl:variable name="var1005_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., '-')">
																						<xsl:if test="fn:ends-with(., '-')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var1004_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var1005_map_result_distinctvalues)">
																				<xsl:variable name="var1010_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1010_cond_result_endswith)">
																					<xsl:sequence select="$var1010_cond_result_endswith"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var1004_map_result_distinctvalues)">
																			<xsl:sequence select="fn:string-join($var1004_map_result_distinctvalues, ' ')"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var972_cond_result_logicalor">
																	<xsl:variable name="var973_cur_cond_result_logicalor" as="xs:string" select="."/>
																	<xsl:variable name="var975_map_select_endtime" as="xs:string?">
																		<xsl:for-each select="$var847_rngdates/endtime">
																			<xsl:variable name="var1002_result_vmf6_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf6_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:variable name="var1001_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1002_result_vmf6_inputtoresult)) then (if (fn:contains($var1002_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																			<xsl:if test="not(fn:exists($var1001_cond_result_exists))">
																				<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:for-each select="fn:distinct-values($var975_map_select_endtime)">
																		<xsl:variable name="var980_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., ':')">
																					<xsl:if test="fn:ends-with(., ':')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var980_cond_result_endswith)">
																			<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var980_cond_result_endswith))), 'un'))">
																				<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var980_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var980_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var980_cond_result_endswith)))))) then 'T' else ()))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var973_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var980_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var980_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var980_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var980_cond_result_endswith)))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:variable name="var1018_cond_result_logicalor" as="xs:string?">
																	<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present')))">
																		<xsl:variable name="var1023_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., '-')">
																						<xsl:if test="fn:ends-with(., '-')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var1022_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var1023_map_result_distinctvalues)">
																				<xsl:variable name="var1028_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1028_cond_result_endswith)">
																					<xsl:sequence select="$var1028_cond_result_endswith"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var1022_map_result_distinctvalues)">
																			<xsl:sequence select="fn:string-join($var1022_map_result_distinctvalues, ' ')"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var1018_cond_result_logicalor">
																	<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="var965_cond_result_exists" as="xs:string*" select="(if (fn:exists($var968_cond_result_exists)) then $var968_cond_result_exists else xs:string((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present')) then fn:current-dateTime() else '')))"/>
													<xsl:for-each select="$var965_cond_result_exists">
														<gml:endPosition>
															<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var847_rngdates/enddate))), 'present')) then 'now' else ()))">
																<xsl:attribute name="indeterminatePosition">
																	<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var847_rngdates/enddate))), 'present')) then 'now' else ())"/>
																</xsl:attribute>
															</xsl:if>
															<xsl:sequence select="xs:string(xs:string(.))"/>
														</gml:endPosition>
													</xsl:for-each>
												</gml:TimePeriod>
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
							</gmd:EX_Extent>
						</gmd:extent>
						<xsl:for-each select="idinfo/descript/supplinf">
							<gmd:supplementalInformation>
								<gco:CharacterString>
									<xsl:sequence select="xs:string(.)"/>
								</gco:CharacterString>
							</gmd:supplementalInformation>
						</xsl:for-each>
					</gmd:MD_DataIdentification>
				</gmd:identificationInfo>
			</xsl:for-each>
			<gmd:contentInfo>
				<gmd:MD_FeatureCatalogueDescription>
					<gmd:includedWithDataset>
						<gco:Boolean>
							<xsl:variable name="var1083_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var1_instance/metadata/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
							<xsl:sequence select="xs:string(fn:boolean($var1083_cond_result_exists))"/>
						</gco:Boolean>
					</gmd:includedWithDataset>
					<xsl:for-each select="$var1_instance/metadata/eainfo/detailed">
						<gmd:featureTypes>
							<gco:LocalName>
								<xsl:attribute name="codeSpace">
									<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(enttyp/enttypl))))"/>
								</xsl:attribute>
							</gco:LocalName>
						</gmd:featureTypes>
					</xsl:for-each>
					<gmd:featureCatalogueCitation>
						<xsl:variable name="var1086_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var1_instance/metadata/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
						<xsl:if test="fn:exists((if ((xs:string($var1086_cond_result_exists) = 'false')) then () else 'unknown'))">
							<xsl:attribute name="gco:nilReason">
								<xsl:sequence select="xs:string(xs:string((if ((xs:string($var1086_cond_result_exists) = 'false')) then () else 'unknown')))"/>
							</xsl:attribute>
						</xsl:if>
						<xsl:variable name="var1087_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1_instance/metadata/eainfo/overview/eaover)) then 'Entity and Attribute Overview: ' else ())"/>
						<xsl:if test="fn:exists($var1087_cond_result_exists)">
							<xsl:variable name="var1088_cond_result_exists" as="xs:string?">
								<xsl:if test="fn:exists($var1_instance/metadata/eainfo/overview/eaover)">
									<xsl:variable name="var1100_map_select_metadata" as="xs:string*">
										<xsl:for-each select="$var1_instance/metadata/eainfo/overview">
											<xsl:sequence select="xs:string(eaover)"/>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var1100_map_select_metadata)">
										<xsl:sequence select="fn:string-join($var1100_map_select_metadata, ' ')"/>
									</xsl:if>
								</xsl:if>
							</xsl:variable>
							<xsl:for-each select="$var1088_cond_result_exists">
								<xsl:variable name="var1089_cur_cond_result_exists" as="xs:string" select="."/>
								<xsl:variable name="var1091_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1_instance/metadata/eainfo/overview/eadetcit)) then '   Entity and Attribute Detail Citation: ' else ())"/>
								<xsl:if test="fn:exists($var1091_cond_result_exists)">
									<xsl:variable name="var1092_cond_result_exists" as="xs:string?">
										<xsl:if test="fn:exists($var1_instance/metadata/eainfo/overview/eadetcit)">
											<xsl:variable name="var1096_map_select_metadata" as="xs:string*">
												<xsl:for-each select="$var1_instance/metadata/eainfo/overview/eadetcit">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var1096_map_select_metadata)">
												<xsl:sequence select="fn:string-join($var1096_map_select_metadata, ' ')"/>
											</xsl:if>
										</xsl:if>
									</xsl:variable>
									<xsl:for-each select="$var1092_cond_result_exists">
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="'Entity and Attribute Information'"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('unknown'))"/>
												</xsl:attribute>
											</gmd:date>
											<gmd:otherCitationDetails>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat($var1087_cond_result_exists, $var1089_cur_cond_result_exists), $var1091_cond_result_exists), .))"/>
												</gco:CharacterString>
											</gmd:otherCitationDetails>
										</gmd:CI_Citation>
									</xsl:for-each>
								</xsl:if>
							</xsl:for-each>
						</xsl:if>
					</gmd:featureCatalogueCitation>
				</gmd:MD_FeatureCatalogueDescription>
				<xsl:for-each select="$var1_instance/metadata/dataqual/cloud">
					<gmd:MD_ImageDescription>
						<gmd:cloudCoverPercentage>
							<xsl:if test="fn:contains(fn:lower-case(xs:string(xs:string(.))), 'unknown')">
								<xsl:attribute name="gco:nilReason">
									<xsl:sequence select="xs:string(xs:string(fn:lower-case(xs:string(xs:string(.)))))"/>
								</xsl:attribute>
							</xsl:if>
							<xsl:if test="not(fn:contains(fn:lower-case(xs:string(xs:string(.))), 'unknown'))">
								<gco:Real>
									<xsl:sequence select="xs:string(xs:double(xs:string(.)))"/>
								</gco:Real>
							</xsl:if>
						</gmd:cloudCoverPercentage>
					</gmd:MD_ImageDescription>
				</xsl:for-each>
			</gmd:contentInfo>
			<gmd:distributionInfo>
				<gmd:MD_Distribution>
					<xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform">
						<xsl:variable name="var1105_digform" as="node()" select="."/>
						<gmd:distributionFormat>
							<gmd:MD_Format>
								<gmd:name>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(xs:string(digtinfo/formname)))"/>
									</gco:CharacterString>
								</gmd:name>
								<gmd:version>
									<xsl:variable name="var1107_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="$var1105_digform/digtinfo/formvern">
												<xsl:for-each select="digtinfo/formvern">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="'unknown'"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var1107_cond_result_exists)">
										<xsl:if test="($var1107_cond_result_exists = 'unknown')">
											<xsl:attribute name="gco:nilReason">
												<xsl:sequence select="xs:string(xs:string($var1107_cond_result_exists))"/>
											</xsl:attribute>
										</xsl:if>
									</xsl:if>
									<xsl:for-each select="digtinfo/formvern">
										<xsl:variable name="var1114_cond_result_equal" as="xs:string?">
											<xsl:if test="not((fn:lower-case(xs:string(.)) = 'unknown'))">
												<xsl:variable name="var1118_map_select_formverd" as="xs:string?">
													<xsl:for-each select="$var1105_digform/digtinfo/formverd">
														<xsl:sequence select="fn:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="var1117_cond_result_exists" as="xs:string?">
													<xsl:choose>
														<xsl:when test="fn:exists($var1118_map_select_formverd)">
															<xsl:for-each select="$var1105_digform/digtinfo/formverd">
																<xsl:sequence select="fn:string(.)"/>
															</xsl:for-each>
														</xsl:when>
														<xsl:otherwise>
															<xsl:sequence select="' '"/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:if test="fn:exists($var1117_cond_result_exists)">
													<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(xs:string(.), $var1117_cond_result_exists)))"/>
												</xsl:if>
											</xsl:if>
										</xsl:variable>
										<xsl:if test="fn:exists($var1114_cond_result_equal)">
											<gco:CharacterString>
												<xsl:sequence select="$var1114_cond_result_equal"/>
											</gco:CharacterString>
										</xsl:if>
									</xsl:for-each>
								</gmd:version>
								<xsl:for-each select="digtinfo/formspec">
									<gmd:specification>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
										</gco:CharacterString>
									</gmd:specification>
								</xsl:for-each>
								<xsl:for-each select="digtinfo/filedec">
									<gmd:fileDecompressionTechnique>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
										</gco:CharacterString>
									</gmd:fileDecompressionTechnique>
								</xsl:for-each>
							</gmd:MD_Format>
						</gmd:distributionFormat>
					</xsl:for-each>
					<xsl:for-each select="$var1_instance/metadata/distinfo">
						<xsl:variable name="var1128_distinfo" as="node()" select="."/>
						<gmd:distributor>
							<gmd:MD_Distributor>
								<gmd:distributorContact>
									<gmd:CI_ResponsibleParty>
										<xsl:variable name="var1131_map_select_cntperp" as="xs:string?">
											<xsl:for-each select="distrib/cntinfo/cntperp/cntper">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:variable name="var1130_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="fn:exists($var1131_map_select_cntperp)">
													<xsl:for-each select="distrib/cntinfo/cntperp/cntper">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:for-each select="distrib/cntinfo/cntorgp/cntper">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:if test="fn:exists($var1130_cond_result_exists)">
											<gmd:individualName>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var1130_cond_result_exists)"/>
												</gco:CharacterString>
											</gmd:individualName>
										</xsl:if>
										<xsl:variable name="var1140_map_select_cntperp" as="xs:string?">
											<xsl:for-each select="distrib/cntinfo/cntperp/cntorg">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:variable name="var1139_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="fn:exists($var1140_map_select_cntperp)">
													<xsl:for-each select="distrib/cntinfo/cntperp/cntorg">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:for-each select="distrib/cntinfo/cntorgp/cntorg">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:if test="fn:exists($var1139_cond_result_exists)">
											<gmd:organisationName>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var1139_cond_result_exists)"/>
												</gco:CharacterString>
											</gmd:organisationName>
										</xsl:if>
										<xsl:for-each select="distrib/cntinfo/cntpos">
											<gmd:positionName>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
												</gco:CharacterString>
											</gmd:positionName>
										</xsl:for-each>
										<gmd:contactInfo>
											<gmd:CI_Contact>
												<gmd:phone>
													<gmd:CI_Telephone>
														<xsl:for-each-group select="distrib/cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
															<xsl:variable name="var1152_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
															<gmd:voice>
																<gco:CharacterString>
																	<xsl:sequence select="$var1152_cur_result_groupby"/>
																</gco:CharacterString>
															</gmd:voice>
														</xsl:for-each-group>
														<xsl:for-each-group select="distrib/cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
															<xsl:variable name="var1156_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
															<gmd:facsimile>
																<gco:CharacterString>
																	<xsl:sequence select="$var1156_cur_result_groupby"/>
																</gco:CharacterString>
															</gmd:facsimile>
														</xsl:for-each-group>
													</gmd:CI_Telephone>
												</gmd:phone>
												<xsl:for-each select="distrib/cntinfo/cntaddr">
													<gmd:address>
														<gmd:CI_Address>
															<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
																<xsl:variable name="var1162_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																<gmd:deliveryPoint>
																	<gco:CharacterString>
																		<xsl:sequence select="$var1162_cur_result_groupby"/>
																	</gco:CharacterString>
																</gmd:deliveryPoint>
															</xsl:for-each-group>
															<gmd:city>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(city))"/>
																</gco:CharacterString>
															</gmd:city>
															<gmd:administrativeArea>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(state))"/>
																</gco:CharacterString>
															</gmd:administrativeArea>
															<gmd:postalCode>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(postal))"/>
																</gco:CharacterString>
															</gmd:postalCode>
															<xsl:for-each select="country">
																<gmd:country>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:country>
															</xsl:for-each>
															<xsl:for-each-group select="$var1128_distinfo/distrib/cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
																<xsl:variable name="var1168_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																<gmd:electronicMailAddress>
																	<gco:CharacterString>
																		<xsl:sequence select="$var1168_cur_result_groupby"/>
																	</gco:CharacterString>
																</gmd:electronicMailAddress>
															</xsl:for-each-group>
														</gmd:CI_Address>
													</gmd:address>
												</xsl:for-each>
												<xsl:for-each select="distrib/cntinfo/hours">
													<gmd:hoursOfService>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:hoursOfService>
												</xsl:for-each>
												<xsl:for-each select="distrib/cntinfo/cntinst">
													<gmd:contactInstructions>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:contactInstructions>
												</xsl:for-each>
											</gmd:CI_Contact>
										</gmd:contactInfo>
										<gmd:role>
											<gmd:CI_RoleCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI('distributor'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI('005'))"/>
												</xsl:attribute>
												<xsl:sequence select="'distributor'"/>
											</gmd:CI_RoleCode>
										</gmd:role>
									</gmd:CI_ResponsibleParty>
								</gmd:distributorContact>
								<xsl:for-each select="stdorder">
									<xsl:variable name="var1174_stdorder" as="node()" select="."/>
									<gmd:distributionOrderProcess>
										<gmd:MD_StandardOrderProcess>
											<gmd:fees>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(fees))"/>
												</gco:CharacterString>
											</gmd:fees>
											<xsl:for-each select="$var1128_distinfo/availabl">
												<xsl:variable name="var1176_availabl" as="node()" select="."/>
												<gmd:plannedAvailableDateTime>
													<xsl:variable name="var1396_map_select_sngdate" as="xs:string?">
														<xsl:for-each select="timeinfo/sngdate">
															<xsl:variable name="var1504_sngdate" as="node()" select="."/>
															<xsl:variable name="var1507_cond_result_logicalor" as="xs:string?">
																<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																	<xsl:variable name="var1545_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., '-')">
																					<xsl:if test="fn:ends-with(., '-')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var1544_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var1545_map_result_distinctvalues)">
																			<xsl:variable name="var1550_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1550_cond_result_endswith)">
																				<xsl:sequence select="$var1550_cond_result_endswith"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1544_map_result_distinctvalues)">
																		<xsl:sequence select="fn:string-join($var1544_map_result_distinctvalues, ' ')"/>
																	</xsl:if>
																</xsl:if>
															</xsl:variable>
															<xsl:for-each select="$var1507_cond_result_logicalor">
																<xsl:variable name="var1508_cur_cond_result_logicalor" as="xs:string" select="."/>
																<xsl:variable name="var1510_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var1176_availabl/timeinfo/sngdate/time)">
																			<xsl:variable name="var1516_map_select_time" as="xs:string?">
																				<xsl:for-each select="$var1504_sngdate/time">
																					<xsl:variable name="var1529_result_vmf6_inputtoresult" as="xs:string?">
																						<xsl:call-template name="vmf:vmf6_inputtoresult">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:variable name="var1528_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1529_result_vmf6_inputtoresult)) then (if (fn:contains($var1529_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																					<xsl:if test="not(fn:exists($var1528_cond_result_exists))">
																						<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1515_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1516_map_select_time)">
																					<xsl:variable name="var1521_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1521_cond_result_endswith)">
																						<xsl:sequence select="fn:string($var1521_cond_result_endswith)"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1515_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1515_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:variable name="var1542_result_vmf6_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf6_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:variable name="var1541_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1542_result_vmf6_inputtoresult)) then (if (fn:contains($var1542_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																			<xsl:variable name="var1531_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1541_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																			<xsl:variable name="var1530_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1531_cond_result_exists)">
																					<xsl:variable name="var1536_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1536_cond_result_endswith)">
																						<xsl:sequence select="fn:string($var1536_cond_result_endswith)"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1530_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1530_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:for-each select="$var1510_cond_result_exists">
																	<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ()))">
																			<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1508_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ())), fn:normalize-space(fn:lower-case(.))))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1181_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var1396_map_select_sngdate)">
																<xsl:for-each select="timeinfo/sngdate">
																	<xsl:variable name="var1398_sngdate" as="node()" select="."/>
																	<xsl:variable name="var1401_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																			<xsl:variable name="var1439_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1438_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1439_map_result_distinctvalues)">
																					<xsl:variable name="var1444_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1444_cond_result_endswith)">
																						<xsl:sequence select="$var1444_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1438_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1438_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1401_cond_result_logicalor">
																		<xsl:variable name="var1402_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1404_cond_result_exists" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:exists($var1176_availabl/timeinfo/sngdate/time)">
																					<xsl:variable name="var1410_map_select_time" as="xs:string?">
																						<xsl:for-each select="$var1398_sngdate/time">
																							<xsl:variable name="var1423_result_vmf6_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf6_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var1422_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1423_result_vmf6_inputtoresult)) then (if (fn:contains($var1423_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var1422_cond_result_exists))">
																								<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1409_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1410_map_select_time)">
																							<xsl:variable name="var1415_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1415_cond_result_endswith)">
																								<xsl:sequence select="fn:string($var1415_cond_result_endswith)"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1409_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1409_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:variable name="var1436_result_vmf6_inputtoresult" as="xs:string?">
																						<xsl:call-template name="vmf:vmf6_inputtoresult">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:variable name="var1435_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1436_result_vmf6_inputtoresult)) then (if (fn:contains($var1436_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																					<xsl:variable name="var1425_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1435_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																					<xsl:variable name="var1424_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1425_cond_result_exists)">
																							<xsl:variable name="var1430_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1430_cond_result_endswith)">
																								<xsl:sequence select="fn:string($var1430_cond_result_endswith)"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1424_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1424_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:for-each select="$var1404_cond_result_exists">
																			<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																				<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ()))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1402_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ())), fn:normalize-space(fn:lower-case(.))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="timeinfo/mdattim/sngdate">
																	<xsl:variable name="var1451_sngdate" as="node()" select="."/>
																	<xsl:variable name="var1454_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																			<xsl:variable name="var1492_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1491_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1492_map_result_distinctvalues)">
																					<xsl:variable name="var1497_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1497_cond_result_endswith)">
																						<xsl:sequence select="$var1497_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1491_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1491_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1454_cond_result_logicalor">
																		<xsl:variable name="var1455_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1457_cond_result_exists" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:exists($var1176_availabl/timeinfo/mdattim/sngdate/time)">
																					<xsl:variable name="var1463_map_select_time" as="xs:string?">
																						<xsl:for-each select="$var1451_sngdate/time">
																							<xsl:variable name="var1476_result_vmf6_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf6_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var1475_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1476_result_vmf6_inputtoresult)) then (if (fn:contains($var1476_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var1475_cond_result_exists))">
																								<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1462_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1463_map_select_time)">
																							<xsl:variable name="var1468_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1468_cond_result_endswith)">
																								<xsl:sequence select="fn:string($var1468_cond_result_endswith)"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1462_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1462_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:variable name="var1489_result_vmf6_inputtoresult" as="xs:string?">
																						<xsl:call-template name="vmf:vmf6_inputtoresult">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:variable name="var1488_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1489_result_vmf6_inputtoresult)) then (if (fn:contains($var1489_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																					<xsl:variable name="var1478_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1488_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																					<xsl:variable name="var1477_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1478_cond_result_exists)">
																							<xsl:variable name="var1483_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1483_cond_result_endswith)">
																								<xsl:sequence select="fn:string($var1483_cond_result_endswith)"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1477_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1477_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:for-each select="$var1457_cond_result_exists">
																			<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																				<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ()))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1455_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ())), fn:normalize-space(fn:lower-case(.))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="var1178_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="$var1181_cond_result_exists">
																<xsl:variable name="var1183_map_select_sngdate" as="xs:string?">
																	<xsl:for-each select="timeinfo/sngdate">
																		<xsl:variable name="var1290_sngdate" as="node()" select="."/>
																		<xsl:variable name="var1293_cond_result_logicalor" as="xs:string?">
																			<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																				<xsl:variable name="var1331_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., '-')">
																								<xsl:if test="fn:ends-with(., '-')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var1330_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var1331_map_result_distinctvalues)">
																						<xsl:variable name="var1336_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1336_cond_result_endswith)">
																							<xsl:sequence select="$var1336_cond_result_endswith"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1330_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var1330_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var1293_cond_result_logicalor">
																			<xsl:variable name="var1294_cur_cond_result_logicalor" as="xs:string" select="."/>
																			<xsl:variable name="var1296_cond_result_exists" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var1176_availabl/timeinfo/sngdate/time)">
																						<xsl:variable name="var1302_map_select_time" as="xs:string?">
																							<xsl:for-each select="$var1290_sngdate/time">
																								<xsl:variable name="var1315_result_vmf6_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf6_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var1314_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1315_result_vmf6_inputtoresult)) then (if (fn:contains($var1315_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var1314_cond_result_exists))">
																									<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var1301_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var1302_map_select_time)">
																								<xsl:variable name="var1307_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1307_cond_result_endswith)">
																									<xsl:sequence select="fn:string($var1307_cond_result_endswith)"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1301_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var1301_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:variable name="var1328_result_vmf6_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf6_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var1327_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1328_result_vmf6_inputtoresult)) then (if (fn:contains($var1328_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:variable name="var1317_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1327_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																						<xsl:variable name="var1316_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var1317_cond_result_exists)">
																								<xsl:variable name="var1322_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1322_cond_result_endswith)">
																									<xsl:sequence select="fn:string($var1322_cond_result_endswith)"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1316_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var1316_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:for-each select="$var1296_cond_result_exists">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ()))">
																						<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1294_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ())), fn:normalize-space(fn:lower-case(.))))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when test="fn:exists($var1183_map_select_sngdate)">
																		<xsl:for-each select="timeinfo/sngdate">
																			<xsl:variable name="var1184_sngdate" as="node()" select="."/>
																			<xsl:variable name="var1187_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																					<xsl:variable name="var1225_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1224_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1225_map_result_distinctvalues)">
																							<xsl:variable name="var1230_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1230_cond_result_endswith)">
																								<xsl:sequence select="$var1230_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1224_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1224_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1187_cond_result_logicalor">
																				<xsl:variable name="var1188_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var1190_cond_result_exists" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:exists($var1176_availabl/timeinfo/sngdate/time)">
																							<xsl:variable name="var1196_map_select_time" as="xs:string?">
																								<xsl:for-each select="$var1184_sngdate/time">
																									<xsl:variable name="var1209_result_vmf6_inputtoresult" as="xs:string?">
																										<xsl:call-template name="vmf:vmf6_inputtoresult">
																											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																										</xsl:call-template>
																									</xsl:variable>
																									<xsl:variable name="var1208_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1209_result_vmf6_inputtoresult)) then (if (fn:contains($var1209_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																									<xsl:if test="not(fn:exists($var1208_cond_result_exists))">
																										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var1195_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1196_map_select_time)">
																									<xsl:variable name="var1201_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var1201_cond_result_endswith)">
																										<xsl:sequence select="fn:string($var1201_cond_result_endswith)"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1195_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var1195_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:variable name="var1222_result_vmf6_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf6_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var1221_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1222_result_vmf6_inputtoresult)) then (if (fn:contains($var1222_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:variable name="var1211_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1221_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																							<xsl:variable name="var1210_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1211_cond_result_exists)">
																									<xsl:variable name="var1216_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var1216_cond_result_endswith)">
																										<xsl:sequence select="fn:string($var1216_cond_result_endswith)"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1210_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var1210_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:for-each select="$var1190_cond_result_exists">
																					<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																						<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ()))">
																							<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1188_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ())), fn:normalize-space(fn:lower-case(.))))"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="timeinfo/mdattim/sngdate">
																			<xsl:variable name="var1237_sngdate" as="node()" select="."/>
																			<xsl:variable name="var1240_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																					<xsl:variable name="var1278_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1277_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1278_map_result_distinctvalues)">
																							<xsl:variable name="var1283_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1283_cond_result_endswith)">
																								<xsl:sequence select="$var1283_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1277_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1277_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1240_cond_result_logicalor">
																				<xsl:variable name="var1241_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var1243_cond_result_exists" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:exists($var1176_availabl/timeinfo/mdattim/sngdate/time)">
																							<xsl:variable name="var1249_map_select_time" as="xs:string?">
																								<xsl:for-each select="$var1237_sngdate/time">
																									<xsl:variable name="var1262_result_vmf6_inputtoresult" as="xs:string?">
																										<xsl:call-template name="vmf:vmf6_inputtoresult">
																											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																										</xsl:call-template>
																									</xsl:variable>
																									<xsl:variable name="var1261_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1262_result_vmf6_inputtoresult)) then (if (fn:contains($var1262_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																									<xsl:if test="not(fn:exists($var1261_cond_result_exists))">
																										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var1248_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1249_map_select_time)">
																									<xsl:variable name="var1254_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var1254_cond_result_endswith)">
																										<xsl:sequence select="fn:string($var1254_cond_result_endswith)"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1248_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var1248_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:variable name="var1275_result_vmf6_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf6_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var1274_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1275_result_vmf6_inputtoresult)) then (if (fn:contains($var1275_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:variable name="var1264_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1274_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																							<xsl:variable name="var1263_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1264_cond_result_exists)">
																									<xsl:variable name="var1269_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var1269_cond_result_endswith)">
																										<xsl:sequence select="fn:string($var1269_cond_result_endswith)"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1263_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var1263_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:for-each select="$var1243_cond_result_exists">
																					<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																						<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ()))">
																							<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1241_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ())), fn:normalize-space(fn:lower-case(.))))"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="timeinfo/rngdates">
																	<xsl:variable name="var1343_rngdates" as="node()" select="."/>
																	<xsl:variable name="var1346_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present')))">
																			<xsl:variable name="var1384_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1383_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1384_map_result_distinctvalues)">
																					<xsl:variable name="var1389_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1389_cond_result_endswith)">
																						<xsl:sequence select="$var1389_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1383_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1383_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1346_cond_result_logicalor">
																		<xsl:variable name="var1347_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1349_cond_result_exists" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:exists($var1176_availabl/timeinfo/rngdates/begtime)">
																					<xsl:variable name="var1355_map_select_begtime" as="xs:string?">
																						<xsl:for-each select="$var1343_rngdates/begtime">
																							<xsl:variable name="var1368_result_vmf6_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf6_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var1367_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1368_result_vmf6_inputtoresult)) then (if (fn:contains($var1368_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var1367_cond_result_exists))">
																								<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1354_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1355_map_select_begtime)">
																							<xsl:variable name="var1360_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1360_cond_result_endswith)">
																								<xsl:sequence select="fn:string($var1360_cond_result_endswith)"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1354_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1354_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:variable name="var1381_result_vmf6_inputtoresult" as="xs:string?">
																						<xsl:call-template name="vmf:vmf6_inputtoresult">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:variable name="var1380_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1381_result_vmf6_inputtoresult)) then (if (fn:contains($var1381_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																					<xsl:variable name="var1370_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1380_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																					<xsl:variable name="var1369_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1370_cond_result_exists)">
																							<xsl:variable name="var1375_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1375_cond_result_endswith)">
																								<xsl:sequence select="fn:string($var1375_cond_result_endswith)"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1369_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1369_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:for-each select="$var1349_cond_result_exists">
																			<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																				<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ()))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1347_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else ())), fn:normalize-space(fn:lower-case(.))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var1178_cond_result_exists">
														<gco:DateTime>
															<xsl:sequence select="xs:string(xs:dateTime(.))"/>
														</gco:DateTime>
													</xsl:for-each>
												</gmd:plannedAvailableDateTime>
											</xsl:for-each>
											<xsl:for-each select="ordering">
												<xsl:variable name="var1557_ordering" as="node()" select="."/>
												<gmd:orderingInstructions>
													<xsl:variable name="var1559_cond_result_exists" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:exists($var1174_stdorder/digform/digtopt/onlinopt/accinstr)">
																<xsl:variable name="var1574_map_select_digform" as="xs:string*">
																	<xsl:for-each select="$var1174_stdorder/digform/digtopt/onlinopt/accinstr">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var1574_map_select_digform)">
																	<xsl:sequence select="fn:string-join($var1574_map_select_digform, ' ')"/>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:sequence select="' '"/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var1559_cond_result_exists">
														<xsl:variable name="var1562_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="$var1174_stdorder/nondig">
																	<xsl:for-each select="$var1174_stdorder/nondig">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="' '"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:if test="fn:exists($var1562_cond_result_exists)">
															<xsl:variable name="var1563_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="$var1128_distinfo/custom">
																		<xsl:for-each select="$var1128_distinfo/custom">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="' '"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var1563_cond_result_exists)">
																<gco:CharacterString>
																	<xsl:variable name="var1564_cond_result_exists" as="xs:string" select="(if (fn:exists($var1174_stdorder/digform/digtopt/onlinopt/accinstr)) then 'Access Instructions: ' else ' ')"/>
																	<xsl:variable name="var1565_cond_result_exists" as="xs:string" select="(if (fn:exists($var1174_stdorder/nondig)) then 'Non-Digital Form: ' else ' ')"/>
																	<xsl:variable name="var1566_cond_result_exists" as="xs:string" select="(if (fn:exists($var1128_distinfo/custom)) then ' Custom Order Process: ' else ' ')"/>
																	<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat($var1564_cond_result_exists, .), $var1565_cond_result_exists), ' '), $var1562_cond_result_exists), ' '), 'Ordering Instructions: '), ' '), xs:string($var1557_ordering)), $var1566_cond_result_exists), $var1563_cond_result_exists)))"/>
																</gco:CharacterString>
															</xsl:if>
														</xsl:if>
													</xsl:for-each>
												</gmd:orderingInstructions>
											</xsl:for-each>
											<xsl:for-each select="turnarnd">
												<gmd:turnaround>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:turnaround>
											</xsl:for-each>
										</gmd:MD_StandardOrderProcess>
									</gmd:distributionOrderProcess>
								</xsl:for-each>
							</gmd:MD_Distributor>
						</gmd:distributor>
					</xsl:for-each>
					<gmd:transferOptions>
						<gmd:MD_DigitalTransferOptions>
							<xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtinfo/transize">
								<gmd:transferSize>
									<gco:Real>
										<xsl:sequence select="xs:string(xs:double(.))"/>
									</gco:Real>
								</gmd:transferSize>
							</xsl:for-each>
							<xsl:variable name="var1581_map_select_metadata" as="xs:string*">
								<xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtopt/onlinopt/computer/networka/networkr">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:variable>
							<xsl:for-each select="fn:distinct-values($var1581_map_select_metadata)">
								<gmd:onLine>
									<gmd:CI_OnlineResource>
										<gmd:linkage>
											<gmd:URL>
												<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(.)))"/>
											</gmd:URL>
										</gmd:linkage>
										<xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtopt/onlinopt/oncomp">
											<gmd:description>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
												</gco:CharacterString>
											</gmd:description>
										</xsl:for-each>
									</gmd:CI_OnlineResource>
								</gmd:onLine>
							</xsl:for-each>
							<xsl:for-each select="$var1_instance/metadata/idinfo/citation/citeinfo/onlink">
								<gmd:onLine>
									<gmd:CI_OnlineResource>
										<gmd:linkage>
											<xsl:for-each select="fn:distinct-values(xs:string(.))">
												<gmd:URL>
													<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(.)))"/>
												</gmd:URL>
											</xsl:for-each>
										</gmd:linkage>
									</gmd:CI_OnlineResource>
								</gmd:onLine>
							</xsl:for-each>
						</gmd:MD_DigitalTransferOptions>
					</gmd:transferOptions>
					<xsl:for-each-group select="$var1_instance/metadata/distinfo/stdorder/digform/digtopt/offoptn" group-by="xs:string(xs:string(offmedia))">
						<xsl:variable name="var1593_cur_result_groupby" as="item()+" select="current-group()"/>
						<gmd:transferOptions>
							<gmd:MD_DigitalTransferOptions>
								<gmd:offLine>
									<gmd:MD_Medium>
										<gmd:name>
											<xsl:variable name="var1633_map_result_groupitems" as="xs:string+">
												<xsl:for-each select="$var1593_cur_result_groupby">
													<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var1632_map_result_distinctvalues" as="xs:string*">
												<xsl:for-each select="fn:distinct-values($var1633_map_result_groupitems)">
													<xsl:variable name="var1636_result_vmf18_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf18_inputtoresult">
															<xsl:with-param name="input" select="fn:upper-case(.)"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var1636_result_vmf18_inputtoresult)">
														<xsl:sequence select="$var1636_result_vmf18_inputtoresult"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var1623_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1632_map_result_distinctvalues)) then fn:string-join($var1632_map_result_distinctvalues, ' ') else ())"/>
											<xsl:variable name="var1596_cond_result_exists" as="xs:string?">
												<xsl:if test="$var1623_cond_result_exists">
													<xsl:variable name="var1626_map_result_groupitems" as="xs:string+">
														<xsl:for-each select="$var1593_cur_result_groupby">
															<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1625_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var1626_map_result_groupitems)">
															<xsl:variable name="var1629_result_vmf18_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf18_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(.)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var1629_result_vmf18_inputtoresult)">
																<xsl:sequence select="$var1629_result_vmf18_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var1625_map_result_distinctvalues)">
														<xsl:sequence select="fn:string-join($var1625_map_result_distinctvalues, ' ')"/>
													</xsl:if>
												</xsl:if>
											</xsl:variable>
											<xsl:if test="fn:exists($var1596_cond_result_exists)">
												<gmd:MD_MediumNameCode>
													<xsl:variable name="var1600_map_result_groupitems" as="xs:string+">
														<xsl:for-each select="$var1593_cur_result_groupby">
															<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1599_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var1600_map_result_groupitems)">
															<xsl:variable name="var1603_result_vmf18_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf18_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(.)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var1603_result_vmf18_inputtoresult)">
																<xsl:sequence select="$var1603_result_vmf18_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1598_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1599_map_result_distinctvalues)) then fn:string-join($var1599_map_result_distinctvalues, ' ') else ())"/>
													<xsl:variable name="var1597_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1598_cond_result_exists)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumNameCode' else ())"/>
													<xsl:if test="fn:exists($var1597_cond_result_exists)">
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI($var1597_cond_result_exists))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI($var1596_cond_result_exists))"/>
													</xsl:attribute>
													<xsl:variable name="var1617_map_result_groupitems" as="xs:string+">
														<xsl:for-each select="$var1593_cur_result_groupby">
															<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1616_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var1617_map_result_groupitems)">
															<xsl:variable name="var1620_result_vmf18_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf18_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(.)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var1620_result_vmf18_inputtoresult)">
																<xsl:sequence select="$var1620_result_vmf18_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1607_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1616_map_result_distinctvalues)) then fn:string-join($var1616_map_result_distinctvalues, ' ') else ())"/>
													<xsl:variable name="var1606_cond_result_exists" as="xs:string?">
														<xsl:if test="$var1607_cond_result_exists">
															<xsl:variable name="var1610_map_result_groupitems" as="xs:string+">
																<xsl:for-each select="$var1593_cur_result_groupby">
																	<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var1609_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values($var1610_map_result_groupitems)">
																	<xsl:variable name="var1613_result_vmf19_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf19_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(.)"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1613_result_vmf19_inputtoresult)">
																		<xsl:sequence select="$var1613_result_vmf19_inputtoresult"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var1609_map_result_distinctvalues)">
																<xsl:sequence select="fn:string-join($var1609_map_result_distinctvalues, ' ')"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:if test="fn:exists($var1606_cond_result_exists)">
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI($var1606_cond_result_exists))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:sequence select="$var1596_cond_result_exists"/>
												</gmd:MD_MediumNameCode>
											</xsl:if>
										</gmd:name>
										<xsl:for-each select="$var1593_cur_result_groupby/reccap/recden">
											<gmd:density>
												<gco:Real>
													<xsl:sequence select="xs:string(xs:double(.))"/>
												</gco:Real>
											</gmd:density>
										</xsl:for-each>
										<xsl:for-each select="$var1593_cur_result_groupby/reccap">
											<gmd:densityUnits>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(recdenu)"/>
												</gco:CharacterString>
											</gmd:densityUnits>
										</xsl:for-each>
										<gmd:mediumFormat>
											<xsl:variable name="var1653_map_result_groupitems" as="xs:string*">
												<xsl:for-each select="$var1593_cur_result_groupby/recfmt">
													<xsl:variable name="var1656_result_vmf20_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf20_inputtoresult">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var1656_result_vmf20_inputtoresult)">
														<xsl:sequence select="$var1656_result_vmf20_inputtoresult"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var1643_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1653_map_result_groupitems)) then fn:string-join($var1653_map_result_groupitems, ' ') else ())"/>
											<xsl:for-each select="$var1643_cond_result_exists">
												<gmd:MD_MediumFormatCode>
													<xsl:attribute name="codeList">
														<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumFormatCode'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI(.))"/>
													</xsl:attribute>
													<xsl:variable name="var1649_map_result_groupitems" as="xs:string*">
														<xsl:for-each select="$var1593_cur_result_groupby/recfmt">
															<xsl:variable name="var1652_result_vmf21_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf21_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var1652_result_vmf21_inputtoresult)">
																<xsl:sequence select="$var1652_result_vmf21_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1646_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1649_map_result_groupitems)) then fn:string-join($var1649_map_result_groupitems, ' ') else ())"/>
													<xsl:for-each select="$var1646_cond_result_exists">
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI(.))"/>
														</xsl:attribute>
													</xsl:for-each>
													<xsl:sequence select="."/>
												</gmd:MD_MediumFormatCode>
											</xsl:for-each>
										</gmd:mediumFormat>
										<xsl:variable name="var1657_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1_instance/metadata/distinfo/stdorder/digform/digtinfo/formcont)) then 'Format Information Content:  ' else ())"/>
										<xsl:if test="fn:exists($var1657_cond_result_exists)">
											<xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtinfo/formcont">
												<xsl:variable name="var1658_formcont" as="node()" select="."/>
												<xsl:variable name="var1660_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1593_cur_result_groupby/compat)) then ' Compatibility Information: ' else ())"/>
												<xsl:if test="fn:exists($var1660_cond_result_exists)">
													<xsl:for-each select="$var1593_cur_result_groupby/compat">
														<gmd:mediumNote>
															<gco:CharacterString>
																<xsl:sequence select="fn:concat(fn:concat(fn:concat($var1657_cond_result_exists, fn:normalize-space(xs:string($var1658_formcont))), $var1660_cond_result_exists), xs:string(.))"/>
															</gco:CharacterString>
														</gmd:mediumNote>
													</xsl:for-each>
												</xsl:if>
											</xsl:for-each>
										</xsl:if>
									</gmd:MD_Medium>
								</gmd:offLine>
							</gmd:MD_DigitalTransferOptions>
						</gmd:transferOptions>
					</xsl:for-each-group>
				</gmd:MD_Distribution>
			</gmd:distributionInfo>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var1663_metadata" as="node()" select="."/>
				<xsl:for-each select="dataqual">
					<gmd:dataQualityInfo>
						<gmd:DQ_DataQuality>
							<gmd:scope>
								<xsl:attribute name="gco:nilReason">
									<xsl:sequence select="xs:string(xs:string('unknown'))"/>
								</xsl:attribute>
							</gmd:scope>
							<xsl:for-each select="posacc/horizpa">
								<gmd:report>
									<gmd:DQ_AbsoluteExternalPositionalAccuracy>
										<gmd:nameOfMeasure>
											<gco:CharacterString>
												<xsl:sequence select="'Horizontal Positional Accuracy'"/>
											</gco:CharacterString>
										</gmd:nameOfMeasure>
										<gmd:measureDescription>
											<xsl:for-each select="qhorizpa">
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(horizpae))"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:measureDescription>
										<gmd:evaluationMethodDescription>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(horizpar))"/>
											</gco:CharacterString>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<gmd:DQ_QuantitativeResult>
												<gmd:valueUnit>
													<gml:BaseUnit>
														<xsl:attribute name="gml:id">
															<xsl:sequence select="xs:string(xs:ID('meters'))"/>
														</xsl:attribute>
														<gml:identifier>
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI('meters'))"/>
															</xsl:attribute>
														</gml:identifier>
														<gml:unitsSystem>
															<xsl:attribute name="xlink:href">
																<xsl:sequence select="xs:string(xs:anyURI('http://www.bipm.org/en/si/'))"/>
															</xsl:attribute>
														</gml:unitsSystem>
													</gml:BaseUnit>
												</gmd:valueUnit>
												<gmd:value>
													<xsl:for-each select="qhorizpa">
														<gco:Record>
															<xsl:sequence select="xs:string(xs:double(horizpav))"/>
														</gco:Record>
													</xsl:for-each>
												</gmd:value>
											</gmd:DQ_QuantitativeResult>
										</gmd:result>
									</gmd:DQ_AbsoluteExternalPositionalAccuracy>
								</gmd:report>
							</xsl:for-each>
							<xsl:for-each select="posacc/vertacc">
								<gmd:report>
									<gmd:DQ_AbsoluteExternalPositionalAccuracy>
										<gmd:nameOfMeasure>
											<gco:CharacterString>
												<xsl:sequence select="'Vertical Positional Accuracy'"/>
											</gco:CharacterString>
										</gmd:nameOfMeasure>
										<gmd:measureDescription>
											<xsl:for-each select="qvertpa">
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(vertacce))"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:measureDescription>
										<gmd:evaluationMethodDescription>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(vertaccr))"/>
											</gco:CharacterString>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<gmd:DQ_QuantitativeResult>
												<gmd:valueUnit>
													<gml:BaseUnit>
														<xsl:attribute name="gml:id">
															<xsl:sequence select="xs:string(xs:ID('meters'))"/>
														</xsl:attribute>
														<gml:identifier>
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI('meters'))"/>
															</xsl:attribute>
														</gml:identifier>
														<gml:unitsSystem>
															<xsl:attribute name="xlink:href">
																<xsl:sequence select="xs:string(xs:anyURI('http://www.bipm.org/en/si/'))"/>
															</xsl:attribute>
														</gml:unitsSystem>
													</gml:BaseUnit>
												</gmd:valueUnit>
												<gmd:value>
													<xsl:for-each select="qvertpa">
														<gco:Record>
															<xsl:sequence select="xs:string(xs:double(vertaccv))"/>
														</gco:Record>
													</xsl:for-each>
												</gmd:value>
											</gmd:DQ_QuantitativeResult>
										</gmd:result>
									</gmd:DQ_AbsoluteExternalPositionalAccuracy>
								</gmd:report>
							</xsl:for-each>
							<gmd:report>
								<gmd:DQ_CompletenessCommission>
									<gmd:result>
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string('unknown'))"/>
										</xsl:attribute>
									</gmd:result>
								</gmd:DQ_CompletenessCommission>
							</gmd:report>
							<gmd:report>
								<gmd:DQ_CompletenessOmission>
									<gmd:evaluationMethodDescription>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(complete))"/>
										</gco:CharacterString>
									</gmd:evaluationMethodDescription>
									<gmd:result>
										<xsl:variable name="var1679_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var1663_metadata/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
										<xsl:if test="fn:exists((if ((xs:string($var1679_cond_result_exists) = 'false')) then () else 'unknown'))">
											<xsl:attribute name="gco:nilReason">
												<xsl:sequence select="xs:string(xs:string((if ((xs:string($var1679_cond_result_exists) = 'false')) then () else 'unknown')))"/>
											</xsl:attribute>
										</xsl:if>
									</gmd:result>
								</gmd:DQ_CompletenessOmission>
							</gmd:report>
							<gmd:report>
								<gmd:DQ_ConceptualConsistency>
									<gmd:measureDescription>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(logic))"/>
										</gco:CharacterString>
									</gmd:measureDescription>
									<gmd:result>
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string('unknown'))"/>
										</xsl:attribute>
									</gmd:result>
								</gmd:DQ_ConceptualConsistency>
							</gmd:report>
							<xsl:for-each select="attracc">
								<xsl:variable name="var1680_attracc" as="node()" select="."/>
								<xsl:for-each select="qattracc">
									<gmd:report>
										<gmd:DQ_QuantitativeAttributeAccuracy>
											<gmd:nameOfMeasure>
												<gco:CharacterString>
													<xsl:sequence select="'Quantitative Attribute Accuracy Assessment'"/>
												</gco:CharacterString>
											</gmd:nameOfMeasure>
											<gmd:measureDescription>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(attracce)"/>
												</gco:CharacterString>
											</gmd:measureDescription>
											<gmd:evaluationMethodDescription>
												<xsl:for-each select="$var1680_attracc/attraccr">
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:evaluationMethodDescription>
											<gmd:result>
												<gmd:DQ_QuantitativeResult>
													<gmd:value>
														<xsl:for-each select="attraccv">
															<gco:Record>
																<xsl:sequence select="xs:string(xs:string(.))"/>
															</gco:Record>
														</xsl:for-each>
													</gmd:value>
												</gmd:DQ_QuantitativeResult>
											</gmd:result>
										</gmd:DQ_QuantitativeAttributeAccuracy>
									</gmd:report>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:for-each select="attracc">
								<gmd:report>
									<gmd:DQ_NonQuantitativeAttributeAccuracy>
										<gmd:measureDescription>
											<gco:CharacterString>
												<xsl:sequence select="xs:string(attraccr)"/>
											</gco:CharacterString>
										</gmd:measureDescription>
										<gmd:result>
											<xsl:attribute name="gco:nilReason">
												<xsl:sequence select="xs:string(xs:string('inapplicable'))"/>
											</xsl:attribute>
										</gmd:result>
									</gmd:DQ_NonQuantitativeAttributeAccuracy>
								</gmd:report>
							</xsl:for-each>
							<gmd:lineage>
								<gmd:LI_Lineage>
									<xsl:for-each select="lineage/procstep">
										<xsl:variable name="var1690_procstep" as="node()" select="."/>
										<gmd:processStep>
											<gmd:LI_ProcessStep>
												<gmd:description>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(procdesc)"/>
													</gco:CharacterString>
												</gmd:description>
												<gmd:dateTime>
													<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unpublished'))">
														<xsl:attribute name="gco:nilReason">
															<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(procdate)))))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:variable name="var1693_cond_result_logicalor" as="xs:string?">
														<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'present')))">
															<xsl:variable name="var1726_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(procdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(procdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(procdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., '-')">
																			<xsl:if test="fn:ends-with(., '-')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var1725_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values($var1726_map_result_distinctvalues)">
																	<xsl:variable name="var1731_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																				<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																						<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1731_cond_result_endswith)">
																		<xsl:sequence select="$var1731_cond_result_endswith"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var1725_map_result_distinctvalues)">
																<xsl:sequence select="fn:string-join($var1725_map_result_distinctvalues, ' ')"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:for-each select="$var1693_cond_result_logicalor">
														<xsl:variable name="var1694_cur_cond_result_logicalor" as="xs:string" select="."/>
														<xsl:variable name="var1696_map_select_proctime" as="xs:string?">
															<xsl:for-each select="$var1690_procstep/proctime">
																<xsl:variable name="var1723_result_vmf6_inputtoresult" as="xs:string?">
																	<xsl:call-template name="vmf:vmf6_inputtoresult">
																		<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:variable name="var1722_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1723_result_vmf6_inputtoresult)) then (if (fn:contains($var1723_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																<xsl:if test="not(fn:exists($var1722_cond_result_exists))">
																	<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																</xsl:if>
															</xsl:for-each>
														</xsl:variable>
														<xsl:for-each select="fn:distinct-values($var1696_map_select_proctime)">
															<xsl:variable name="var1701_cond_result_endswith" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:ends-with(., ':')">
																		<xsl:if test="fn:ends-with(., ':')">
																			<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																				<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="."/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var1701_cond_result_endswith)">
																<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1701_cond_result_endswith))), 'un'))">
																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1701_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1701_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1701_cond_result_endswith)))))) then 'T' else ()))">
																		<gco:DateTime>
																			<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1694_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1701_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1701_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1701_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var1701_cond_result_endswith))))))))"/>
																		</gco:DateTime>
																	</xsl:if>
																</xsl:if>
															</xsl:if>
														</xsl:for-each>
													</xsl:for-each>
												</gmd:dateTime>
												<xsl:for-each select="proccont">
													<xsl:variable name="var1738_proccont" as="node()" select="."/>
													<gmd:processor>
														<gmd:CI_ResponsibleParty>
															<gmd:individualName>
																<xsl:variable name="var1741_map_select_cntperp" as="xs:string?">
																	<xsl:for-each select="cntinfo/cntperp/cntper">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var1740_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var1741_map_select_cntperp)">
																			<xsl:for-each select="cntinfo/cntperp/cntper">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="cntinfo/cntorgp/cntper">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var1740_cond_result_exists)">
																	<gco:CharacterString>
																		<xsl:sequence select="$var1740_cond_result_exists"/>
																	</gco:CharacterString>
																</xsl:if>
															</gmd:individualName>
															<gmd:organisationName>
																<xsl:variable name="var1750_map_select_cntperp" as="xs:string?">
																	<xsl:for-each select="cntinfo/cntperp/cntorg">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var1749_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var1750_map_select_cntperp)">
																			<xsl:for-each select="cntinfo/cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="cntinfo/cntorgp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var1749_cond_result_exists)">
																	<gco:CharacterString>
																		<xsl:sequence select="$var1749_cond_result_exists"/>
																	</gco:CharacterString>
																</xsl:if>
															</gmd:organisationName>
															<gmd:positionName>
																<xsl:for-each select="cntinfo/cntpos">
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:positionName>
															<gmd:contactInfo>
																<gmd:CI_Contact>
																	<gmd:phone>
																		<gmd:CI_Telephone>
																			<xsl:for-each-group select="cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
																				<xsl:variable name="var1762_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																				<gmd:voice>
																					<gco:CharacterString>
																						<xsl:sequence select="$var1762_cur_result_groupby"/>
																					</gco:CharacterString>
																				</gmd:voice>
																			</xsl:for-each-group>
																			<xsl:for-each-group select="cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
																				<xsl:variable name="var1766_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																				<gmd:facsimile>
																					<gco:CharacterString>
																						<xsl:sequence select="$var1766_cur_result_groupby"/>
																					</gco:CharacterString>
																				</gmd:facsimile>
																			</xsl:for-each-group>
																		</gmd:CI_Telephone>
																	</gmd:phone>
																	<xsl:for-each select="cntinfo/cntaddr">
																		<gmd:address>
																			<gmd:CI_Address>
																				<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
																					<xsl:variable name="var1772_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																					<gmd:deliveryPoint>
																						<gco:CharacterString>
																							<xsl:sequence select="$var1772_cur_result_groupby"/>
																						</gco:CharacterString>
																					</gmd:deliveryPoint>
																				</xsl:for-each-group>
																				<gmd:city>
																					<gco:CharacterString>
																						<xsl:sequence select="xs:string(city)"/>
																					</gco:CharacterString>
																				</gmd:city>
																				<gmd:administrativeArea>
																					<gco:CharacterString>
																						<xsl:sequence select="xs:string(state)"/>
																					</gco:CharacterString>
																				</gmd:administrativeArea>
																				<gmd:postalCode>
																					<gco:CharacterString>
																						<xsl:sequence select="xs:string(postal)"/>
																					</gco:CharacterString>
																				</gmd:postalCode>
																				<gmd:country>
																					<xsl:for-each select="country">
																						<gco:CharacterString>
																							<xsl:sequence select="xs:string(.)"/>
																						</gco:CharacterString>
																					</xsl:for-each>
																				</gmd:country>
																				<xsl:for-each-group select="$var1738_proccont/cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
																					<xsl:variable name="var1778_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																					<gmd:electronicMailAddress>
																						<gco:CharacterString>
																							<xsl:sequence select="$var1778_cur_result_groupby"/>
																						</gco:CharacterString>
																					</gmd:electronicMailAddress>
																				</xsl:for-each-group>
																			</gmd:CI_Address>
																		</gmd:address>
																	</xsl:for-each>
																	<gmd:hoursOfService>
																		<xsl:for-each select="cntinfo/hours">
																			<gco:CharacterString>
																				<xsl:sequence select="xs:string(.)"/>
																			</gco:CharacterString>
																		</xsl:for-each>
																	</gmd:hoursOfService>
																	<gmd:contactInstructions>
																		<xsl:for-each select="cntinfo/cntinst">
																			<gco:CharacterString>
																				<xsl:sequence select="xs:string(.)"/>
																			</gco:CharacterString>
																		</xsl:for-each>
																	</gmd:contactInstructions>
																</gmd:CI_Contact>
															</gmd:contactInfo>
															<gmd:role>
																<xsl:variable name="var1806_map_select_cntperp" as="xs:string?">
																	<xsl:for-each select="cntinfo/cntperp/cntorg">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var1805_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var1806_map_select_cntperp)">
																			<xsl:for-each select="cntinfo/cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="cntinfo/cntorgp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:variable name="var1784_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1805_cond_result_exists)) then 'processor' else ())"/>
																<xsl:if test="fn:exists($var1784_cond_result_exists)">
																	<gmd:CI_RoleCode>
																		<xsl:variable name="var1787_map_select_cntperp" as="xs:string?">
																			<xsl:for-each select="cntinfo/cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var1786_cond_result_exists" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:exists($var1787_map_select_cntperp)">
																					<xsl:for-each select="cntinfo/cntperp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:for-each select="cntinfo/cntorgp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:variable name="var1785_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1786_cond_result_exists)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode' else ())"/>
																		<xsl:if test="fn:exists($var1785_cond_result_exists)">
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI($var1785_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:attribute name="codeListValue">
																			<xsl:sequence select="xs:string(xs:anyURI($var1784_cond_result_exists))"/>
																		</xsl:attribute>
																		<xsl:variable name="var1797_map_select_cntperp" as="xs:string?">
																			<xsl:for-each select="cntinfo/cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var1796_cond_result_exists" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:exists($var1797_map_select_cntperp)">
																					<xsl:for-each select="cntinfo/cntperp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:for-each select="cntinfo/cntorgp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:variable name="var1795_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1796_cond_result_exists)) then '009' else ())"/>
																		<xsl:if test="fn:exists($var1795_cond_result_exists)">
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI($var1795_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:sequence select="$var1784_cond_result_exists"/>
																	</gmd:CI_RoleCode>
																</xsl:if>
															</gmd:role>
														</gmd:CI_ResponsibleParty>
													</gmd:processor>
												</xsl:for-each>
												<xsl:for-each-group select="." group-by="grp:key0acecdb0(.)">
													<xsl:variable name="var1817_cur_result_groupby" as="item()+" select="current-group()"/>
													<xsl:variable name="var1818_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
													<gmd:source>
														<gmd:LI_Source>
															<gmd:sourceCitation>
																<gmd:CI_Citation>
																	<gmd:title>
																		<gco:CharacterString>
																			<xsl:sequence select="$var1818_cur_result_groupby"/>
																		</gco:CharacterString>
																	</gmd:title>
																	<xsl:for-each select="$var1817_cur_result_groupby/srcprod">
																		<gmd:alternateTitle>
																			<gco:CharacterString>
																				<xsl:sequence select="xs:string(.)"/>
																			</gco:CharacterString>
																		</gmd:alternateTitle>
																	</xsl:for-each>
																	<gmd:date>
																		<xsl:attribute name="gco:nilReason">
																			<xsl:sequence select="xs:string(xs:string('unknown'))"/>
																		</xsl:attribute>
																	</gmd:date>
																</gmd:CI_Citation>
															</gmd:sourceCitation>
														</gmd:LI_Source>
													</gmd:source>
												</xsl:for-each-group>
											</gmd:LI_ProcessStep>
										</gmd:processStep>
									</xsl:for-each>
									<xsl:for-each select="lineage/srcinfo">
										<xsl:variable name="var1822_srcinfo" as="node()" select="."/>
										<gmd:source>
											<gmd:LI_Source>
												<gmd:description>
													<gco:CharacterString>
														<xsl:sequence select="fn:concat(fn:concat('Source Contribution: ', xs:string(srccontr)), xs:string(xs:string(typesrc)))"/>
													</gco:CharacterString>
												</gmd:description>
												<gmd:scaleDenominator>
													<gmd:MD_RepresentativeFraction>
														<gmd:denominator>
															<xsl:for-each select="srcscale">
																<xsl:if test="(fn:lower-case(fn:string(.)) = 'unknown')">
																	<xsl:attribute name="gco:nilReason">
																		<xsl:sequence select="xs:string(xs:string(fn:string(.)))"/>
																	</xsl:attribute>
																</xsl:if>
															</xsl:for-each>
															<xsl:for-each select="srcscale">
																<xsl:if test="not((fn:lower-case(fn:string(.)) = 'unknown'))">
																	<gco:Integer>
																		<xsl:sequence select="xs:string(xs:integer(.))"/>
																	</gco:Integer>
																</xsl:if>
															</xsl:for-each>
														</gmd:denominator>
													</gmd:MD_RepresentativeFraction>
												</gmd:scaleDenominator>
												<gmd:sourceCitation>
													<gmd:CI_Citation>
														<gmd:title>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(srccite/citeinfo/title)"/>
															</gco:CharacterString>
														</gmd:title>
														<gmd:alternateTitle>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(srccitea)"/>
															</gco:CharacterString>
														</gmd:alternateTitle>
														<gmd:date>
															<gmd:CI_Date>
																<gmd:date>
																	<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unpublished'))">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate)))))"/>
																		</xsl:attribute>
																	</xsl:if>
																	<xsl:variable name="var1829_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'present')))">
																			<xsl:variable name="var1834_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1833_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1834_map_result_distinctvalues)">
																					<xsl:variable name="var1839_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1839_cond_result_endswith)">
																						<xsl:sequence select="$var1839_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1833_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1833_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1829_cond_result_logicalor">
																		<gco:Date>
																			<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																		</gco:Date>
																	</xsl:for-each>
																	<xsl:variable name="var1847_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'present')))">
																			<xsl:variable name="var1880_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1879_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1880_map_result_distinctvalues)">
																					<xsl:variable name="var1885_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1885_cond_result_endswith)">
																						<xsl:sequence select="$var1885_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1879_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1879_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1847_cond_result_logicalor">
																		<xsl:variable name="var1848_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1850_map_select_pubtime" as="xs:string?">
																			<xsl:for-each select="$var1822_srcinfo/srccite/citeinfo/pubtime">
																				<xsl:variable name="var1877_result_vmf6_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf6_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var1876_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1877_result_vmf6_inputtoresult)) then (if (fn:contains($var1877_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var1876_cond_result_exists))">
																					<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var1850_map_select_pubtime)">
																			<xsl:variable name="var1855_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1855_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1855_cond_result_endswith))), 'un'))">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1855_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1855_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1855_cond_result_endswith)))))) then 'T' else ()))">
																						<gco:DateTime>
																							<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1848_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1855_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1855_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1855_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var1855_cond_result_endswith)))))))"/>
																						</gco:DateTime>
																					</xsl:if>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</gmd:date>
																<gmd:dateType>
																	<gmd:CI_DateTypeCode>
																		<xsl:attribute name="codeList">
																			<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
																		</xsl:attribute>
																		<xsl:attribute name="codeListValue">
																			<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
																		</xsl:attribute>
																		<xsl:attribute name="codeSpace">
																			<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
																		</xsl:attribute>
																		<xsl:sequence select="'publication'"/>
																	</gmd:CI_DateTypeCode>
																</gmd:dateType>
															</gmd:CI_Date>
														</gmd:date>
														<gmd:edition>
															<xsl:for-each select="srccite/citeinfo/edition">
																<gco:CharacterString>
																	<xsl:sequence select="xs:string(.)"/>
																</gco:CharacterString>
															</xsl:for-each>
														</gmd:edition>
														<xsl:for-each-group select="srccite/citeinfo" group-by="grp:key0d4338f0(.)">
															<xsl:variable name="var1898_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
															<gmd:citedResponsibleParty>
																<gmd:CI_ResponsibleParty>
																	<gmd:organisationName>
																		<gco:CharacterString>
																			<xsl:sequence select="$var1898_cur_result_groupby"/>
																		</gco:CharacterString>
																	</gmd:organisationName>
																	<gmd:role>
																		<gmd:CI_RoleCode>
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																			</xsl:attribute>
																			<xsl:attribute name="codeListValue">
																				<xsl:sequence select="xs:string(xs:anyURI('resourceProvider'))"/>
																			</xsl:attribute>
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI('001'))"/>
																			</xsl:attribute>
																			<xsl:sequence select="'resourceProvider'"/>
																		</gmd:CI_RoleCode>
																	</gmd:role>
																</gmd:CI_ResponsibleParty>
															</gmd:citedResponsibleParty>
														</xsl:for-each-group>
														<gmd:presentationForm>
															<xsl:variable name="var1900_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="$var1822_srcinfo/srccite/citeinfo/geoform">
																		<xsl:for-each select="srccite/citeinfo/geoform">
																			<xsl:variable name="var1911_result_vmf7_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf7_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1911_result_vmf7_inputtoresult)">
																				<xsl:sequence select="$var1911_result_vmf7_inputtoresult"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="srccite/citeinfo/geoform">
																			<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var1900_cond_result_exists)">
																<gmd:CI_PresentationFormCode>
																	<xsl:variable name="var1901_cond_result_exists" as="xs:string?" select="(if (fn:exists(srccite/citeinfo/geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode' else ())"/>
																	<xsl:if test="fn:exists($var1901_cond_result_exists)">
																		<xsl:attribute name="codeList">
																			<xsl:sequence select="xs:string(xs:anyURI($var1901_cond_result_exists))"/>
																		</xsl:attribute>
																	</xsl:if>
																	<xsl:attribute name="codeListValue">
																		<xsl:sequence select="xs:string(xs:anyURI($var1900_cond_result_exists))"/>
																	</xsl:attribute>
																	<xsl:variable name="var1902_cond_result_exists" as="xs:string?">
																		<xsl:if test="$var1822_srcinfo/srccite/citeinfo/geoform">
																			<xsl:for-each select="srccite/citeinfo/geoform">
																				<xsl:variable name="var1906_result_vmf8_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf8_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1906_result_vmf8_inputtoresult)">
																					<xsl:sequence select="$var1906_result_vmf8_inputtoresult"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1902_cond_result_exists)">
																		<xsl:attribute name="codeSpace">
																			<xsl:sequence select="xs:string(xs:anyURI($var1902_cond_result_exists))"/>
																		</xsl:attribute>
																	</xsl:if>
																	<xsl:sequence select="$var1900_cond_result_exists"/>
																</gmd:CI_PresentationFormCode>
															</xsl:if>
														</gmd:presentationForm>
														<gmd:series>
															<gmd:CI_Series>
																<gmd:name>
																	<xsl:for-each select="srccite/citeinfo/serinfo">
																		<gco:CharacterString>
																			<xsl:sequence select="xs:string(sername)"/>
																		</gco:CharacterString>
																	</xsl:for-each>
																</gmd:name>
																<gmd:issueIdentification>
																	<xsl:for-each select="srccite/citeinfo/serinfo">
																		<gco:CharacterString>
																			<xsl:sequence select="xs:string(issue)"/>
																		</gco:CharacterString>
																	</xsl:for-each>
																</gmd:issueIdentification>
															</gmd:CI_Series>
														</gmd:series>
														<gmd:otherCitationDetails>
															<xsl:for-each select="srccite/citeinfo/othercit">
																<gco:CharacterString>
																	<xsl:sequence select="xs:string(.)"/>
																</gco:CharacterString>
															</xsl:for-each>
														</gmd:otherCitationDetails>
													</gmd:CI_Citation>
												</gmd:sourceCitation>
												<gmd:sourceExtent>
													<gmd:EX_Extent>
														<xsl:for-each select="srctime/timeinfo/sngdate">
															<xsl:variable name="var1920_sngdate" as="node()" select="."/>
															<gmd:temporalElement>
																<gmd:EX_TemporalExtent>
																	<gmd:extent>
																		<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
																			<xsl:attribute name="gco:nilReason">
																				<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<gml:TimeInstant>
																			<xsl:attribute name="gml:id">
																				<xsl:sequence select="xs:string(xs:ID('sourceTemporalExtent'))"/>
																			</xsl:attribute>
																			<gml:description>
																				<xsl:sequence select="xs:string(xs:string($var1822_srcinfo/srctime/srccurr))"/>
																			</gml:description>
																			<xsl:variable name="var1993_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																					<xsl:variable name="var2026_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2025_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var2026_map_result_distinctvalues)">
																							<xsl:variable name="var2031_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2031_cond_result_endswith)">
																								<xsl:sequence select="$var2031_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2025_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var2025_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:variable name="var1926_map_cond_result_logicalor" as="xs:string*">
																				<xsl:for-each select="$var1993_cond_result_logicalor">
																					<xsl:variable name="var1994_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:variable name="var1996_map_select_time" as="xs:string?">
																						<xsl:for-each select="$var1920_sngdate/time">
																							<xsl:variable name="var2023_result_vmf6_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf6_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var2022_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2023_result_vmf6_inputtoresult)) then (if (fn:contains($var2023_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var2022_cond_result_exists))">
																								<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:for-each select="fn:distinct-values($var1996_map_select_time)">
																						<xsl:variable name="var2001_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., ':')">
																									<xsl:if test="fn:ends-with(., ':')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2001_cond_result_endswith)">
																							<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var2001_cond_result_endswith))), 'un'))">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2001_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2001_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2001_cond_result_endswith)))))) then 'T' else ()))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1994_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2001_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2001_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2001_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var2001_cond_result_endswith)))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1925_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var1926_map_cond_result_logicalor)">
																						<xsl:variable name="var1929_cond_result_logicalor" as="xs:string?">
																							<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																								<xsl:variable name="var1962_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., '-')">
																												<xsl:if test="fn:ends-with(., '-')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var1961_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var1962_map_result_distinctvalues)">
																										<xsl:variable name="var1967_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var1967_cond_result_endswith)">
																											<xsl:sequence select="$var1967_cond_result_endswith"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1961_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var1961_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:variable>
																						<xsl:for-each select="$var1929_cond_result_logicalor">
																							<xsl:variable name="var1930_cur_cond_result_logicalor" as="xs:string" select="."/>
																							<xsl:variable name="var1932_map_select_time" as="xs:string?">
																								<xsl:for-each select="$var1920_sngdate/time">
																									<xsl:variable name="var1959_result_vmf6_inputtoresult" as="xs:string?">
																										<xsl:call-template name="vmf:vmf6_inputtoresult">
																											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																										</xsl:call-template>
																									</xsl:variable>
																									<xsl:variable name="var1958_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1959_result_vmf6_inputtoresult)) then (if (fn:contains($var1959_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																									<xsl:if test="not(fn:exists($var1958_cond_result_exists))">
																										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:for-each select="fn:distinct-values($var1932_map_select_time)">
																								<xsl:variable name="var1937_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1937_cond_result_endswith)">
																									<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1937_cond_result_endswith))), 'un'))">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1937_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1937_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1937_cond_result_endswith)))))) then 'T' else ()))">
																											<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1930_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1937_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1937_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1937_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var1937_cond_result_endswith)))))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:variable name="var1975_cond_result_logicalor" as="xs:string?">
																							<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																								<xsl:variable name="var1980_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., '-')">
																												<xsl:if test="fn:ends-with(., '-')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var1979_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var1980_map_result_distinctvalues)">
																										<xsl:variable name="var1985_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var1985_cond_result_endswith)">
																											<xsl:sequence select="$var1985_cond_result_endswith"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1979_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var1979_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:variable>
																						<xsl:for-each select="$var1975_cond_result_logicalor">
																							<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:variable name="var1922_cond_result_exists" as="xs:string*" select="(if (fn:exists($var1925_cond_result_exists)) then $var1925_cond_result_exists else xs:string((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')) then fn:current-dateTime() else '')))"/>
																			<xsl:for-each select="$var1922_cond_result_exists">
																				<gml:timePosition>
																					<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var1920_sngdate/caldate))), 'present')) then 'now' else ()))">
																						<xsl:attribute name="indeterminatePosition">
																							<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var1920_sngdate/caldate))), 'present')) then 'now' else ())"/>
																						</xsl:attribute>
																					</xsl:if>
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</gml:timePosition>
																			</xsl:for-each>
																		</gml:TimeInstant>
																	</gmd:extent>
																</gmd:EX_TemporalExtent>
															</gmd:temporalElement>
														</xsl:for-each>
														<xsl:for-each select="srctime/timeinfo/mdattim/sngdate">
															<xsl:variable name="var2038_sngdate" as="node()" select="."/>
															<gmd:temporalElement>
																<gmd:EX_TemporalExtent>
																	<gmd:extent>
																		<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
																			<xsl:attribute name="gco:nilReason">
																				<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(caldate)))))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<gml:TimeInstant>
																			<xsl:attribute name="gml:id">
																				<xsl:sequence select="xs:string(xs:ID('sourceTemporalExtent'))"/>
																			</xsl:attribute>
																			<gml:description>
																				<xsl:sequence select="xs:string(xs:string($var1822_srcinfo/srctime/srccurr))"/>
																			</gml:description>
																			<xsl:variable name="var2112_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																					<xsl:variable name="var2145_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2144_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var2145_map_result_distinctvalues)">
																							<xsl:variable name="var2150_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2150_cond_result_endswith)">
																								<xsl:sequence select="$var2150_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2144_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var2144_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:variable name="var2045_map_cond_result_logicalor" as="xs:string*">
																				<xsl:for-each select="$var2112_cond_result_logicalor">
																					<xsl:variable name="var2113_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:variable name="var2115_map_select_time" as="xs:string?">
																						<xsl:for-each select="$var2038_sngdate/time">
																							<xsl:variable name="var2142_result_vmf6_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf6_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var2141_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2142_result_vmf6_inputtoresult)) then (if (fn:contains($var2142_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var2141_cond_result_exists))">
																								<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:for-each select="fn:distinct-values($var2115_map_select_time)">
																						<xsl:variable name="var2120_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., ':')">
																									<xsl:if test="fn:ends-with(., ':')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2120_cond_result_endswith)">
																							<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var2120_cond_result_endswith))), 'un'))">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2120_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2120_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2120_cond_result_endswith)))))) then 'T' else ()))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2113_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2120_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2120_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2120_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var2120_cond_result_endswith)))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var2044_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var2045_map_cond_result_logicalor)">
																						<xsl:variable name="var2048_cond_result_logicalor" as="xs:string?">
																							<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																								<xsl:variable name="var2081_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., '-')">
																												<xsl:if test="fn:ends-with(., '-')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var2080_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var2081_map_result_distinctvalues)">
																										<xsl:variable name="var2086_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var2086_cond_result_endswith)">
																											<xsl:sequence select="$var2086_cond_result_endswith"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2080_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var2080_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:variable>
																						<xsl:for-each select="$var2048_cond_result_logicalor">
																							<xsl:variable name="var2049_cur_cond_result_logicalor" as="xs:string" select="."/>
																							<xsl:variable name="var2051_map_select_time" as="xs:string?">
																								<xsl:for-each select="$var2038_sngdate/time">
																									<xsl:variable name="var2078_result_vmf6_inputtoresult" as="xs:string?">
																										<xsl:call-template name="vmf:vmf6_inputtoresult">
																											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																										</xsl:call-template>
																									</xsl:variable>
																									<xsl:variable name="var2077_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2078_result_vmf6_inputtoresult)) then (if (fn:contains($var2078_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																									<xsl:if test="not(fn:exists($var2077_cond_result_exists))">
																										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:for-each select="fn:distinct-values($var2051_map_select_time)">
																								<xsl:variable name="var2056_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2056_cond_result_endswith)">
																									<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var2056_cond_result_endswith))), 'un'))">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2056_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2056_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2056_cond_result_endswith)))))) then 'T' else ()))">
																											<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2049_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2056_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2056_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2056_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var2056_cond_result_endswith)))))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:variable name="var2094_cond_result_logicalor" as="xs:string?">
																							<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')))">
																								<xsl:variable name="var2099_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(caldate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., '-')">
																												<xsl:if test="fn:ends-with(., '-')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var2098_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var2099_map_result_distinctvalues)">
																										<xsl:variable name="var2104_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var2104_cond_result_endswith)">
																											<xsl:sequence select="$var2104_cond_result_endswith"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2098_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var2098_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:variable>
																						<xsl:for-each select="$var2094_cond_result_logicalor">
																							<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:variable name="var2040_cond_result_exists" as="xs:string*" select="(if (fn:exists($var2044_cond_result_exists)) then $var2044_cond_result_exists else xs:string((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'present')) then fn:current-dateTime() else '')))"/>
																			<xsl:for-each select="$var2040_cond_result_exists">
																				<gml:timePosition>
																					<xsl:variable name="var2043_cond_result_exists" as="xs:string?" select="(if (fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var2038_sngdate/caldate))), 'present')) then 'now' else ()))) then (if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var2038_sngdate/caldate))), 'present')) then 'now' else ()) else 'unknown')"/>
																					<xsl:if test="fn:exists($var2043_cond_result_exists)">
																						<xsl:attribute name="indeterminatePosition">
																							<xsl:sequence select="$var2043_cond_result_exists"/>
																						</xsl:attribute>
																					</xsl:if>
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</gml:timePosition>
																			</xsl:for-each>
																		</gml:TimeInstant>
																	</gmd:extent>
																</gmd:EX_TemporalExtent>
															</gmd:temporalElement>
														</xsl:for-each>
														<xsl:for-each select="srctime/timeinfo/rngdates">
															<xsl:variable name="var2157_rngdates" as="node()" select="."/>
															<gmd:temporalElement>
																<gmd:EX_TemporalExtent>
																	<gmd:extent>
																		<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished'))">
																			<xsl:attribute name="gco:nilReason">
																				<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(begdate)))))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<gml:TimePeriod>
																			<xsl:attribute name="gml:id">
																				<xsl:sequence select="xs:string(xs:ID('sourceTemporalExtent'))"/>
																			</xsl:attribute>
																			<gml:description>
																				<xsl:sequence select="xs:string(xs:string($var1822_srcinfo/srctime/srccurr))"/>
																			</gml:description>
																			<xsl:variable name="var2230_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present')))">
																					<xsl:variable name="var2263_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2262_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var2263_map_result_distinctvalues)">
																							<xsl:variable name="var2268_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2268_cond_result_endswith)">
																								<xsl:sequence select="$var2268_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2262_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var2262_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:variable name="var2163_map_cond_result_logicalor" as="xs:string*">
																				<xsl:for-each select="$var2230_cond_result_logicalor">
																					<xsl:variable name="var2231_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:variable name="var2233_map_select_begtime" as="xs:string?">
																						<xsl:for-each select="$var2157_rngdates/begtime">
																							<xsl:variable name="var2260_result_vmf6_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf6_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var2259_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2260_result_vmf6_inputtoresult)) then (if (fn:contains($var2260_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var2259_cond_result_exists))">
																								<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:for-each select="fn:distinct-values($var2233_map_select_begtime)">
																						<xsl:variable name="var2238_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., ':')">
																									<xsl:if test="fn:ends-with(., ':')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2238_cond_result_endswith)">
																							<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var2238_cond_result_endswith))), 'un'))">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2238_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2238_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2238_cond_result_endswith)))))) then 'T' else ()))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2231_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2238_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2238_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2238_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var2238_cond_result_endswith)))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var2162_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var2163_map_cond_result_logicalor)">
																						<xsl:variable name="var2166_cond_result_logicalor" as="xs:string?">
																							<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present')))">
																								<xsl:variable name="var2199_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., '-')">
																												<xsl:if test="fn:ends-with(., '-')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var2198_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var2199_map_result_distinctvalues)">
																										<xsl:variable name="var2204_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var2204_cond_result_endswith)">
																											<xsl:sequence select="$var2204_cond_result_endswith"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2198_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var2198_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:variable>
																						<xsl:for-each select="$var2166_cond_result_logicalor">
																							<xsl:variable name="var2167_cur_cond_result_logicalor" as="xs:string" select="."/>
																							<xsl:variable name="var2169_map_select_begtime" as="xs:string?">
																								<xsl:for-each select="$var2157_rngdates/begtime">
																									<xsl:variable name="var2196_result_vmf6_inputtoresult" as="xs:string?">
																										<xsl:call-template name="vmf:vmf6_inputtoresult">
																											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																										</xsl:call-template>
																									</xsl:variable>
																									<xsl:variable name="var2195_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2196_result_vmf6_inputtoresult)) then (if (fn:contains($var2196_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																									<xsl:if test="not(fn:exists($var2195_cond_result_exists))">
																										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:for-each select="fn:distinct-values($var2169_map_select_begtime)">
																								<xsl:variable name="var2174_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2174_cond_result_endswith)">
																									<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var2174_cond_result_endswith))), 'un'))">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2174_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2174_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2174_cond_result_endswith)))))) then 'T' else ()))">
																											<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2167_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2174_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2174_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2174_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var2174_cond_result_endswith)))))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:variable name="var2212_cond_result_logicalor" as="xs:string?">
																							<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present')))">
																								<xsl:variable name="var2217_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(begdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., '-')">
																												<xsl:if test="fn:ends-with(., '-')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var2216_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var2217_map_result_distinctvalues)">
																										<xsl:variable name="var2222_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var2222_cond_result_endswith)">
																											<xsl:sequence select="$var2222_cond_result_endswith"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2216_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var2216_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:variable>
																						<xsl:for-each select="$var2212_cond_result_logicalor">
																							<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:variable name="var2159_cond_result_exists" as="xs:string*" select="(if (fn:exists($var2162_cond_result_exists)) then $var2162_cond_result_exists else xs:string((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'present')) then fn:current-dateTime() else '')))"/>
																			<xsl:for-each select="$var2159_cond_result_exists">
																				<gml:beginPosition>
																					<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var2157_rngdates/begdate))), 'present')) then 'now' else ()))">
																						<xsl:attribute name="indeterminatePosition">
																							<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var2157_rngdates/begdate))), 'present')) then 'now' else ())"/>
																						</xsl:attribute>
																					</xsl:if>
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</gml:beginPosition>
																			</xsl:for-each>
																			<xsl:variable name="var2346_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present')))">
																					<xsl:variable name="var2379_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2378_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var2379_map_result_distinctvalues)">
																							<xsl:variable name="var2384_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2384_cond_result_endswith)">
																								<xsl:sequence select="$var2384_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2378_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var2378_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:variable name="var2279_map_cond_result_logicalor" as="xs:string*">
																				<xsl:for-each select="$var2346_cond_result_logicalor">
																					<xsl:variable name="var2347_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:variable name="var2349_map_select_endtime" as="xs:string?">
																						<xsl:for-each select="$var2157_rngdates/endtime">
																							<xsl:variable name="var2376_result_vmf6_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf6_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var2375_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2376_result_vmf6_inputtoresult)) then (if (fn:contains($var2376_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var2375_cond_result_exists))">
																								<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:for-each select="fn:distinct-values($var2349_map_select_endtime)">
																						<xsl:variable name="var2354_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., ':')">
																									<xsl:if test="fn:ends-with(., ':')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2354_cond_result_endswith)">
																							<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var2354_cond_result_endswith))), 'un'))">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2354_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2354_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2354_cond_result_endswith)))))) then 'T' else ()))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2347_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2354_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2354_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2354_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var2354_cond_result_endswith)))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var2278_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var2279_map_cond_result_logicalor)">
																						<xsl:variable name="var2282_cond_result_logicalor" as="xs:string?">
																							<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present')))">
																								<xsl:variable name="var2315_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., '-')">
																												<xsl:if test="fn:ends-with(., '-')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var2314_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var2315_map_result_distinctvalues)">
																										<xsl:variable name="var2320_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var2320_cond_result_endswith)">
																											<xsl:sequence select="$var2320_cond_result_endswith"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2314_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var2314_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:variable>
																						<xsl:for-each select="$var2282_cond_result_logicalor">
																							<xsl:variable name="var2283_cur_cond_result_logicalor" as="xs:string" select="."/>
																							<xsl:variable name="var2285_map_select_endtime" as="xs:string?">
																								<xsl:for-each select="$var2157_rngdates/endtime">
																									<xsl:variable name="var2312_result_vmf6_inputtoresult" as="xs:string?">
																										<xsl:call-template name="vmf:vmf6_inputtoresult">
																											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																										</xsl:call-template>
																									</xsl:variable>
																									<xsl:variable name="var2311_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2312_result_vmf6_inputtoresult)) then (if (fn:contains($var2312_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																									<xsl:if test="not(fn:exists($var2311_cond_result_exists))">
																										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:for-each select="fn:distinct-values($var2285_map_select_endtime)">
																								<xsl:variable name="var2290_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2290_cond_result_endswith)">
																									<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var2290_cond_result_endswith))), 'un'))">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2290_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2290_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2290_cond_result_endswith)))))) then 'T' else ()))">
																											<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2283_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2290_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2290_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2290_cond_result_endswith)))))) then 'T' else ())), fn:normalize-space(fn:lower-case(fn:string($var2290_cond_result_endswith)))))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:variable name="var2328_cond_result_logicalor" as="xs:string?">
																							<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present')))">
																								<xsl:variable name="var2333_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(enddate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., '-')">
																												<xsl:if test="fn:ends-with(., '-')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var2332_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var2333_map_result_distinctvalues)">
																										<xsl:variable name="var2338_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var2338_cond_result_endswith)">
																											<xsl:sequence select="$var2338_cond_result_endswith"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2332_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var2332_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:variable>
																						<xsl:for-each select="$var2328_cond_result_logicalor">
																							<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:variable name="var2275_cond_result_exists" as="xs:string*" select="(if (fn:exists($var2278_cond_result_exists)) then $var2278_cond_result_exists else xs:string((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(enddate))), 'present')) then fn:current-dateTime() else '')))"/>
																			<xsl:for-each select="$var2275_cond_result_exists">
																				<gml:endPosition>
																					<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var2157_rngdates/enddate))), 'present')) then 'now' else ()))">
																						<xsl:attribute name="indeterminatePosition">
																							<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string($var2157_rngdates/enddate))), 'present')) then 'now' else ())"/>
																						</xsl:attribute>
																					</xsl:if>
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</gml:endPosition>
																			</xsl:for-each>
																		</gml:TimePeriod>
																	</gmd:extent>
																</gmd:EX_TemporalExtent>
															</gmd:temporalElement>
														</xsl:for-each>
													</gmd:EX_Extent>
												</gmd:sourceExtent>
											</gmd:LI_Source>
										</gmd:source>
									</xsl:for-each>
								</gmd:LI_Lineage>
							</gmd:lineage>
						</gmd:DQ_DataQuality>
					</gmd:dataQualityInfo>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var2391_metadata" as="node()" select="."/>
				<xsl:for-each select="metainfo/metac">
					<gmd:metadataConstraints>
						<gmd:MD_LegalConstraints>
							<gmd:accessConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
									</xsl:attribute>
								</gmd:MD_RestrictionCode>
							</gmd:accessConstraints>
							<gmd:useConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:if test="$var2391_metadata/metainfo/metuc">
										<xsl:attribute name="codeList">
											<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
										</xsl:attribute>
									</xsl:if>
									<xsl:if test="$var2391_metadata/metainfo/metuc">
										<xsl:attribute name="codeListValue">
											<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
										</xsl:attribute>
									</xsl:if>
									<xsl:if test="$var2391_metadata/metainfo/metuc">
										<xsl:attribute name="codeSpace">
											<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
										</xsl:attribute>
									</xsl:if>
								</gmd:MD_RestrictionCode>
							</gmd:useConstraints>
							<gmd:otherConstraints>
								<xsl:variable name="var2395_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="$var2391_metadata/metainfo/metuc">
											<xsl:for-each select="$var2391_metadata/metainfo/metuc">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="' '"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var2395_cond_result_exists)">
									<gco:CharacterString>
										<xsl:variable name="var2396_cond_result_exists" as="xs:string" select="(if (fn:exists($var2391_metadata/metainfo/metuc)) then ' Metadata Use Constraints: ' else ' ')"/>
										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat('Metadata Access Constraints: ', xs:string(.)), $var2396_cond_result_exists), $var2395_cond_result_exists))"/>
									</gco:CharacterString>
								</xsl:if>
							</gmd:otherConstraints>
						</gmd:MD_LegalConstraints>
					</gmd:metadataConstraints>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/metainfo/metsi">
				<gmd:metadataConstraints>
					<gmd:MD_SecurityConstraints>
						<gmd:classification>
							<gmd:MD_ClassificationCode>
								<xsl:variable name="var2403_result_vmf13_inputtoresult" as="xs:string?">
									<xsl:call-template name="vmf:vmf13_inputtoresult">
										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(metsc))))"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="var2402_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2403_result_vmf13_inputtoresult)) then $var2403_result_vmf13_inputtoresult else ())"/>
								<xsl:if test="fn:exists($var2402_cond_result_exists)">
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI($var2402_cond_result_exists))"/>
									</xsl:attribute>
								</xsl:if>
								<xsl:attribute name="codeListValue">
									<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"/>
								</xsl:attribute>
								<xsl:variable name="var2405_result_vmf14_inputtoresult" as="xs:string?">
									<xsl:call-template name="vmf:vmf14_inputtoresult">
										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(metsc))))"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="var2404_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2405_result_vmf14_inputtoresult)) then $var2405_result_vmf14_inputtoresult else ())"/>
								<xsl:if test="fn:exists($var2404_cond_result_exists)">
									<xsl:attribute name="codeSpace">
										<xsl:sequence select="xs:string(xs:anyURI($var2404_cond_result_exists))"/>
									</xsl:attribute>
								</xsl:if>
							</gmd:MD_ClassificationCode>
						</gmd:classification>
						<gmd:classificationSystem>
							<gco:CharacterString>
								<xsl:sequence select="xs:string(metscs)"/>
							</gco:CharacterString>
						</gmd:classificationSystem>
					</gmd:MD_SecurityConstraints>
				</gmd:metadataConstraints>
			</xsl:for-each>
			<gmd:metadataMaintenance>
				<gmd:MD_MaintenanceInformation>
					<gmd:maintenanceAndUpdateFrequency>
						<xsl:attribute name="gco:nilReason">
							<xsl:sequence select="xs:string(xs:string('unknown'))"/>
						</xsl:attribute>
					</gmd:maintenanceAndUpdateFrequency>
					<xsl:for-each select="$var1_instance/metadata/metainfo/metfrd">
						<gmd:dateOfNextUpdate>
							<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished'))">
								<xsl:attribute name="gco:nilReason">
									<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(xs:string(.))))))"/>
								</xsl:attribute>
							</xsl:if>
							<xsl:variable name="var2409_cond_result_logicalor" as="xs:string?">
								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'present')))">
									<xsl:variable name="var2414_map_result_distinctvalues" as="xs:string*">
										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
											<xsl:choose>
												<xsl:when test="fn:ends-with(., '-')">
													<xsl:if test="fn:ends-with(., '-')">
														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
														</xsl:if>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="."/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var2413_map_result_distinctvalues" as="xs:string*">
										<xsl:for-each select="fn:distinct-values($var2414_map_result_distinctvalues)">
											<xsl:variable name="var2419_cond_result_endswith" as="xs:string?">
												<xsl:choose>
													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
															</xsl:if>
														</xsl:if>
													</xsl:when>
													<xsl:otherwise>
														<xsl:sequence select="."/>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:if test="fn:exists($var2419_cond_result_endswith)">
												<xsl:sequence select="$var2419_cond_result_endswith"/>
											</xsl:if>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var2413_map_result_distinctvalues)">
										<xsl:sequence select="fn:string-join($var2413_map_result_distinctvalues, ' ')"/>
									</xsl:if>
								</xsl:if>
							</xsl:variable>
							<xsl:for-each select="$var2409_cond_result_logicalor">
								<gco:Date>
									<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
								</gco:Date>
							</xsl:for-each>
						</gmd:dateOfNextUpdate>
					</xsl:for-each>
					<gmd:maintenanceNote>
						<xsl:for-each select="$var1_instance/metadata">
							<xsl:variable name="var2430_map_select_metadata" as="xs:string?">
								<xsl:for-each select="$var1_instance/metadata/metainfo/metrd">
									<xsl:variable name="var2434_cond_result_logicalor" as="xs:string?">
										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
											<xsl:variable name="var2439_map_result_distinctvalues" as="xs:string*">
												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
													<xsl:choose>
														<xsl:when test="fn:ends-with(., '-')">
															<xsl:if test="fn:ends-with(., '-')">
																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																</xsl:if>
															</xsl:if>
														</xsl:when>
														<xsl:otherwise>
															<xsl:sequence select="."/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var2438_map_result_distinctvalues" as="xs:string*">
												<xsl:for-each select="fn:distinct-values($var2439_map_result_distinctvalues)">
													<xsl:variable name="var2444_cond_result_endswith" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																	</xsl:if>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:sequence select="."/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:if test="fn:exists($var2444_cond_result_endswith)">
														<xsl:sequence select="$var2444_cond_result_endswith"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var2438_map_result_distinctvalues)">
												<xsl:sequence select="fn:string-join($var2438_map_result_distinctvalues, ' ')"/>
											</xsl:if>
										</xsl:if>
									</xsl:variable>
									<xsl:for-each select="$var2434_cond_result_logicalor">
										<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
									</xsl:for-each>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var2428_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2430_map_select_metadata)) then $var2430_map_select_metadata else ' ')"/>
							<xsl:if test="fn:exists($var2428_cond_result_exists)">
								<gco:CharacterString>
									<xsl:variable name="var2429_cond_result_exists" as="xs:string" select="(if (fn:exists($var1_instance/metadata/metainfo/metrd)) then ' Metadata Review Date: ' else ' ')"/>
									<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat('This metadata was automatically generated from the ', xs:string(xs:string(metainfo/metstdn))), 'standard version '), xs:string(metainfo/metstdv)), ' using the January 2013 version of the FGDC CSDGM to ISO 19115-2 transform.'), $var2429_cond_result_exists), $var2428_cond_result_exists)))"/>
								</gco:CharacterString>
							</xsl:if>
						</xsl:for-each>
					</gmd:maintenanceNote>
					<gmd:contact>
						<gmd:CI_ResponsibleParty>
							<gmd:individualName>
								<xsl:variable name="var2452_map_select_metadata" as="xs:string?">
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
										<xsl:sequence select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:variable>
								<xsl:variable name="var2451_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="fn:exists($var2452_map_select_metadata)">
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntper">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var2451_cond_result_exists)">
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space($var2451_cond_result_exists)"/>
									</gco:CharacterString>
								</xsl:if>
							</gmd:individualName>
							<gmd:organisationName>
								<xsl:variable name="var2461_map_select_metadata" as="xs:string?">
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
										<xsl:sequence select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:variable>
								<xsl:variable name="var2460_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="fn:exists($var2461_map_select_metadata)">
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntorg">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var2460_cond_result_exists)">
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space($var2460_cond_result_exists)"/>
									</gco:CharacterString>
								</xsl:if>
							</gmd:organisationName>
							<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntpos">
								<gmd:positionName>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:positionName>
							</xsl:for-each>
							<gmd:contactInfo>
								<gmd:CI_Contact>
									<gmd:phone>
										<gmd:CI_Telephone>
											<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var2473_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:voice>
													<gco:CharacterString>
														<xsl:sequence select="$var2473_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:voice>
											</xsl:for-each-group>
											<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var2477_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:facsimile>
													<gco:CharacterString>
														<xsl:sequence select="$var2477_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:facsimile>
											</xsl:for-each-group>
										</gmd:CI_Telephone>
									</gmd:phone>
									<xsl:for-each select="$var1_instance/metadata">
										<xsl:variable name="var2479_metadata" as="node()" select="."/>
										<xsl:for-each select="metainfo/metc/cntinfo/cntaddr">
											<gmd:address>
												<gmd:CI_Address>
													<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
														<xsl:variable name="var2485_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:deliveryPoint>
															<gco:CharacterString>
																<xsl:sequence select="$var2485_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:deliveryPoint>
													</xsl:for-each-group>
													<gmd:city>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(city))"/>
														</gco:CharacterString>
													</gmd:city>
													<gmd:administrativeArea>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(state))"/>
														</gco:CharacterString>
													</gmd:administrativeArea>
													<gmd:postalCode>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(postal))"/>
														</gco:CharacterString>
													</gmd:postalCode>
													<xsl:for-each select="country">
														<gmd:country>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
															</gco:CharacterString>
														</gmd:country>
													</xsl:for-each>
													<xsl:for-each-group select="$var2479_metadata/metainfo/metc/cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
														<xsl:variable name="var2491_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:electronicMailAddress>
															<gco:CharacterString>
																<xsl:sequence select="$var2491_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:electronicMailAddress>
													</xsl:for-each-group>
												</gmd:CI_Address>
											</gmd:address>
										</xsl:for-each>
									</xsl:for-each>
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/hours">
										<gmd:hoursOfService>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:hoursOfService>
									</xsl:for-each>
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntinst">
										<gmd:contactInstructions>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:contactInstructions>
									</xsl:for-each>
								</gmd:CI_Contact>
							</gmd:contactInfo>
							<gmd:role>
								<gmd:CI_RoleCode>
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:sequence select="xs:string(xs:anyURI('custodian'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
									</xsl:attribute>
									<xsl:sequence select="'custodian'"/>
								</gmd:CI_RoleCode>
							</gmd:role>
						</gmd:CI_ResponsibleParty>
					</gmd:contact>
				</gmd:MD_MaintenanceInformation>
			</gmd:metadataMaintenance>
		</gmi:MI_Metadata>
	</xsl:template>
</xsl:stylesheet>
